#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
#ifndef PIXELSDK_SWIFT_H
#define PIXELSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import AVFoundation;
@import CoreGraphics;
@import CoreMedia;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="PixelSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif




@protocol CameraControllerDelegate;
@class UIView;
@class AVCapturePhotoSettings;
@class NSCoder;
@class UITraitCollection;
@protocol UIViewControllerTransitionCoordinator;
@class NSString;
@class NSBundle;

/// The <code>CameraController</code> can take photos with low UI latency and Vine style video while also applying realtime filters.
/// Filters can be applied by swiping left or right in the camera view, or by pressing the filters button.
/// The filters can be changed with the <code>PixelSDK.primaryFilters</code> variable.
/// <em>Figure 1</em> Camera controller
/// <img src="https://www.cdn.pixelsdk.com/assets/img/screenshots/sdk/camera_1.jpg" alt="Screenshot" width="190" height="auto" style="border-style: solid; border-width: 1px; border-color: LightGrey;"/>
/// This controller is used inside the <code>ContainerController</code> and can be used on its own by initializing
/// the container controller with only one mode <code>.photo</code> or <code>.video</code>.
/// The camera can be restricted to produce only content of a specific aspect ratio. For example square content:
/// \code
/// container.cameraController.aspectRatio = CGSize(width: 1, height: 1)
///
/// \endcodeBy default, the camera controller pushes an <code>EditController</code> onto the navigation stack after a photo or video is taken. This can be disabled by setting <code>showsEditControllerWhenDone</code> to false. You will also need to implement the <code>CameraControllerDelegate</code> in order to respond the <code>CameraControllerDelegate.cameraController(_:didFinishWithSession:)</code> delegate method.
SWIFT_CLASS("_TtC8PixelSDK16CameraController")
@interface CameraController : UIViewController
/// Set this delegate in order to handle events that occur in this controller.
/// Default value: <code>nil</code>
@property (nonatomic, weak) id <CameraControllerDelegate> _Nullable delegate;
/// Set this to false if you do not want the <code>EditController</code> pushed onto the navigation stack
/// after the user takes a photo or presses the Done button after taking a video.
/// You can push your own controller or dismiss this controller in the <code>CameraControllerDelegate.cameraController(_:didFinishWithSession:)</code> delegate method.
/// Default value: <code>true</code>
@property (nonatomic) BOOL showsEditControllerWhenDone;
/// Set this to true if you want the flash enabled.
/// Default value: <code>false</code>
@property (nonatomic) BOOL flashActive;
/// Set this to true if you want the front facing camera enabled or to false if you want the back facing camera enabled.
/// Default value: <code>false</code>
@property (nonatomic) BOOL frontFacingCameraActive;
/// Set this to true if you want the brightness slider to be visible.
/// Default value: <code>false</code>
@property (nonatomic) BOOL brightnessAdjustmentActive;
/// When true, if the device is held horizontally with the screen face up, the mode pictured below will appear.
/// <img src="https://www.cdn.pixelsdk.com/assets/img/docs/face_up_mode.jpg" alt="Face up mode" title="Face up mode" width="250" height="auto"/>
/// Default value: <code>true</code>
@property (nonatomic) BOOL faceUpModeAvailable;
/// When true, the user may double tap anywhere inside the camera view to switch between the front and back facing camera.
/// Default value: <code>true</code>
@property (nonatomic) BOOL doubleTapForFrontFacingCamera;
/// Optionally provide a custom view for the photo camera button. Your view must determine its own size with intrinsic content size or constraints.
/// Default value: <code>nil</code>
@property (nonatomic, strong) UIView * _Nullable photoCameraButtonView;
/// Optionally provide a custom view for the video camera button. Your view must determine its own size with intrinsic content size or constraints.
/// Default value: <code>nil</code>
@property (nonatomic, strong) UIView * _Nullable videoCameraButtonView;
/// The <a href="https://developer.apple.com/documentation/avfoundation/avcapturesession/preset">session preset</a> for video capture.
/// Default value: <code>.high</code>
@property (nonatomic) AVCaptureSessionPreset _Nonnull videoPreset;
/// A closure that returns newly allocated <a href="https://developer.apple.com/documentation/avfoundation/avcapturephotosettings">photo settings</a> for photo capture.
/// If you wish to enable or disable flash, set the <code>flashActive</code> variable.
/// Default value:
/// \code
/// {
///     let photoSettings = AVCapturePhotoSettings()
///     photoSettings.isAutoStillImageStabilizationEnabled = true
///     photoSettings.isHighResolutionPhotoEnabled = true
///     return photoSettings
/// }
///
/// \endcode
@property (nonatomic, copy) AVCapturePhotoSettings * _Nonnull (^ _Nonnull photoSettings)(void);
/// Use <code>aspectRatio</code> instead to enable square camera.
/// Default value: <code>false</code>
@property (nonatomic) BOOL squareCameraActive SWIFT_DEPRECATED_MSG("Only set aspectRatio now. This variable is no longer needed.");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// :nodoc:
- (void)viewDidLoad;
/// :nodoc:
- (void)viewWillAppear:(BOOL)animated;
/// :nodoc:
- (void)viewDidAppear:(BOOL)animated;
/// :nodoc:
- (void)viewWillDisappear:(BOOL)animated;
/// :nodoc:
- (void)viewDidDisappear:(BOOL)animated;
/// :nodoc:
- (void)viewWillLayoutSubviews;
/// :nodoc:
- (void)willTransitionToTraitCollection:(UITraitCollection * _Nonnull)newCollection withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
@property (nonatomic, readonly) UIStatusBarStyle preferredStatusBarStyle;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end




@interface CameraController (SWIFT_EXTENSION(PixelSDK))
@property (nonatomic, readonly) BOOL prefersBottomBarTransparent;
@end




@interface CameraController (SWIFT_EXTENSION(PixelSDK))
- (void)setNeedsBottomBarAppearanceUpdate;
@property (nonatomic, readonly, strong) UIView * _Nullable preferredBottomBarView;
@property (nonatomic, readonly) BOOL prefersBottomBarHidden;
@end





@class Session;
@class EditController;

/// Use this delegate to handle events that occur in the <code>CameraController</code>.
SWIFT_PROTOCOL("_TtP8PixelSDK24CameraControllerDelegate_")
@protocol CameraControllerDelegate
@optional
/// This will be called when the Cross button is pressed.
/// \param cameraController The controller responsible for calling this method.
///
- (void)cameraControllerDidCancel:(CameraController * _Nonnull)cameraController;
/// This will be called when a photo is taken or the Done button is pressed while taking video.
/// \param cameraController The controller responsible for calling this method.
///
/// \param session The session that was generated by the <code>CameraController</code>.
/// If <code>showsEditControllerWhenDone</code> is false, you are responsible for destroying the session if you do not want it to persist.
/// If it is true, destroying the session will result in undocumented behavior.
///
- (void)cameraController:(CameraController * _Nonnull)cameraController didFinishWithSession:(Session * _Nonnull)session;
/// This will be called when a photo is taken or the Done button is pressed while taking video, and <code>showsEditControllerWhenDone</code> is true.
/// If you wish to make any additional customizations to the ‘EditController’ before it is pushed, you may do so here.
/// \param cameraController The controller responsible for calling this method.
///
/// \param editController The new <code>EditController</code> that will be pushed onto the navigation stack.
///
/// \param session The session that was generated by the <code>CameraController</code> and will be
/// passed to the <code>EditController</code>. Destroying the session will result in undocumented behavior.
///
- (void)cameraController:(CameraController * _Nonnull)cameraController willShowEditController:(EditController * _Nonnull)editController withSession:(Session * _Nonnull)session;
/// This is called when the user began pressing the photo camera button to initiate capture.
/// You can implement this method to produce a custom shutter sound or haptic feedback.
/// \param cameraController The controller responsible for calling this method.
///
- (void)cameraControllerPhotoCameraButtonTouchesBegan:(CameraController * _Nonnull)cameraController;
/// This is called when the user finished pressing the photo camera button to initiate capture.
/// You can implement this method to produce a custom shutter sound or haptic feedback.
/// \param cameraController The controller responsible for calling this method.
///
- (void)cameraControllerPhotoCameraButtonTouchesEnded:(CameraController * _Nonnull)cameraController;
/// This is called when the user finished pressing the photo camera button to initiate capture but the touch was ignored.
/// \param cameraController The controller responsible for calling this method.
///
- (void)cameraControllerPhotoCameraButtonTouchesCancelled:(CameraController * _Nonnull)cameraController;
/// This is called when the user began pressing the video camera button to initiate capture.
/// You can implement this method to produce a custom shutter sound or haptic feedback.
/// \param cameraController The controller responsible for calling this method.
///
- (void)cameraControllerVideoCameraButtonTouchesBegan:(CameraController * _Nonnull)cameraController;
/// This is called when the user finished pressing the video camera button to finish capture.
/// You can implement this method to produce a custom shutter sound or haptic feedback.
/// \param cameraController The controller responsible for calling this method.
///
- (void)cameraControllerVideoCameraButtonTouchesEnded:(CameraController * _Nonnull)cameraController;
/// This is called when the user finished pressing the video camera button to finish capture but the touch was ignored.
/// \param cameraController The controller responsible for calling this method.
///
- (void)cameraControllerVideoCameraButtonTouchesCancelled:(CameraController * _Nonnull)cameraController;
@end

@protocol ContainerControllerDelegate;
@protocol EditControllerDelegate;
@class LibraryController;

/// The <code>ContainerController</code> view consists of a tab bar at the bottom and a controller above it.
/// Each tab is represented by a <code>ContainerMode</code> with an associated controller and title for the tab.
/// The tab bar can be customized by initializing this controller with the modes of your choosing.
/// If you initialize a <code>ContainerController</code> with only one mode, the tab bar will be automatically hidden.
SWIFT_CLASS("_TtC8PixelSDK19ContainerController")
@interface ContainerController : UIViewController
/// Creates a <code>ContainerController</code> with the modes <code>[.library, .photo, .video]</code>
/// and an initialMode of <code>.photo</code>. For additional information see <code>init(modes:initialMode:restoresPreviousMode:)</code>.
- (nonnull instancetype)init;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// Set this delegate in order to handle events that occur in this controller or any of its children controllers.
/// Default value: <code>nil</code>
@property (nonatomic, weak) id <ContainerControllerDelegate> _Nullable delegate;
/// Whenever the <code>LibraryController</code> or <code>CameraController</code> pushes a new <code>EditController</code> onto the navigation stack
/// it will always set its delegate to whatever the value of this variable is.
/// You should set this so you can respond to user interaction in the <code>EditController</code>.
/// Default value: <code>nil</code>
@property (nonatomic, weak) id <EditControllerDelegate> _Nullable editControllerDelegate;
/// The instance of the <code>CameraController</code> that will be displayed for either the .photo or .video modes.
@property (nonatomic, readonly, strong) CameraController * _Nonnull cameraController;
/// The instance of the <code>LibraryController</code> that will be displayed for the .library mode.
@property (nonatomic, readonly, strong) LibraryController * _Nonnull libraryController;
/// :nodoc:
- (void)viewDidLoad;
/// :nodoc:
- (void)viewWillAppear:(BOOL)animated;
/// :nodoc:
- (void)viewWillDisappear:(BOOL)animated;
/// :nodoc:
- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
- (void)willTransitionToTraitCollection:(UITraitCollection * _Nonnull)newCollection withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
@property (nonatomic, readonly) UIInterfaceOrientationMask supportedInterfaceOrientations;
/// :nodoc:
@property (nonatomic, readonly, strong) UIViewController * _Nullable childViewControllerForStatusBarStyle;
/// :nodoc:
@property (nonatomic, readonly) BOOL prefersStatusBarHidden;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end



@interface ContainerController (SWIFT_EXTENSION(PixelSDK))
@property (nonatomic, readonly) BOOL prefersBottomBarHidden;
@property (nonatomic, readonly, strong) UIView * _Nullable preferredBottomBarView;
- (void)setNeedsBottomBarAppearanceUpdate;
@end


/// Use this delegate to handle events that occur in the <code>ContainerController</code> or any of its children controllers.
SWIFT_PROTOCOL("_TtP8PixelSDK27ContainerControllerDelegate_")
@protocol ContainerControllerDelegate
@optional
/// This will be called whenever the user switches between tabs.
/// You can retrieve the new mode from the <code>ContainerController.currentMode</code> variable.
/// \param containerController The controller responsible for calling this method.
///
- (void)containerControllerDidChangeMode:(ContainerController * _Nonnull)containerController;
/// This will be called when either the Cancel button is pressed in the <code>LibraryController</code> or the cross
/// button is pressed in the <code>CameraController</code>.
/// \param containerController The controller responsible for calling this method.
///
- (void)containerControllerDidCancel:(ContainerController * _Nonnull)containerController;
/// This will be called when either the <code>LibraryController</code> or <code>CameraController</code> is about to push a
/// new <code>EditController</code> onto the navigation stack. If you wish to make any additional customizations to the <code>EditController</code>
/// before it is pushed, you may do so here.
/// \param containerController The controller responsible for calling this method.
///
/// \param editController The new <code>EditController</code> that will be pushed onto the navigation stack.
///
/// \param session The session that was generated by the <code>LibraryController</code> or <code>CameraController</code> and will be
/// passed to the <code>EditController</code>. Destroying the session will result in undocumented behavior.
///
- (void)containerController:(ContainerController * _Nonnull)containerController willShowEditController:(EditController * _Nonnull)editController withSession:(Session * _Nonnull)session;
@end

///
typedef SWIFT_ENUM(NSInteger, ContentMode, open) {
/// Media scaled to fill the space. Distortion may occur.
  ContentModeContentFill = 0,
/// Media scaled to fit the space while maintaining the media’s original aspect ratio.
  ContentModeContentAspectFit = 1,
/// Media scaled to fill the space while maintaining the media’s original aspect ratio. A portion of the media may be clipped or spill out of the space.
  ContentModeContentAspectFill = 2,
};


@class UIButton;

/// The primary functionality of the <code>EditController</code> includes filter selection, filter intensity, adjustments (brightness, vibrance, saturation, etc.), cropping, rotation, horizontal/vertical perspective correction, and video segment composing/trimming/re-ordering.
/// The edit controller is always presented with an image or video based <code>Session</code> object. Sessions can be edited programmatically by changing filters, crop rects, trim times and more. The edit controller will display all programmatic changes to a session in its interface. For more information on modifying a session see the <code>Session</code> documentation.
/// When presented with an image based session, the controller consists of two tabs Filter and Adjust. When presented with a video, the controller consists of three tabs Filter, Trim and Adjust. You may edit media of any aspect ratio. All editing functionality available to images is also available to videos.
/// Normally the edit controller is pushed onto the navigation stack by either the <code>LibraryController</code> or <code>CameraController</code>. You may also present the edit controller manually with a <code>Session</code> for example:
/// \code
/// let image = UIImage(named: "test_image")!
///
/// let session = Session(image: image)
///
/// let editController = EditController(session: session)
/// editController.delegate = self
///
/// let nav = UINavigationController(rootViewController: editController)
/// nav.modalPresentationStyle = .fullScreen
/// self.present(nav, animated: true, completion: nil)
///
/// \endcodeattention:
/// Sessions are automatically saved so you a responsible for calling <code>Session.destroy()</code> when you are done with a session (unless noted otherwise). If you do not destroy a session it will persist in the users Drafts in memory and on disk.
/// You may also present an edit controller with one or more AVAssets, for example:
/// \code
/// let asset1 = AVAsset(url: Bundle.main.url(forResource: "test", withExtension: "mov")!)
/// let asset2 = AVAsset(url: Bundle.main.url(forResource: "test2", withExtension: "mp4")!)
///
/// let _ = Session(assets: [asset1, asset2], sessionReady: { (session, error) in
///     guard let session = session else {
///         print("Unable to create session: \(error!)")
///         return
///     }
///
///     let editController = EditController(session: session)
///     editController.delegate = self
///
///     let nav = UINavigationController(rootViewController: editController)
///     nav.modalPresentationStyle = .fullScreen
///     self.present(nav, animated: true, completion: nil)
/// })
///
/// \endcodeFilters under the Filter or Adjust tabs may be changed by setting the <code>PixelSDK.primaryFilters</code> <code>PixelSDK.adjustmentFilters</code> variables respectively.
/// The Adjust tab places the Position (cropping) button before the adjust filters. Cropping can be disabled by setting <code>showsPositionAdjustment</code> to false.
SWIFT_CLASS("_TtC8PixelSDK14EditController")
@interface EditController : UIViewController
/// Creates an <code>EditController</code> with the provided session. The session you pass here will be automatically saved when any changes are made by the controller.
/// warning:
/// Modifying the session after the controller has been presented may result in undocumented behavior.
/// precondition:
/// Provided session must not be destroyed.
/// \param session The session to initialize the <code>EditController</code> with.
///
- (nonnull instancetype)initWithSession:(Session * _Nonnull)session OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// The session the <code>EditController</code> was initialized with.
@property (nonatomic, readonly, strong) Session * _Nonnull session;
/// Set this delegate in order to handle events that occur in this controller.
/// Default value: <code>nil</code>
@property (nonatomic, weak) id <EditControllerDelegate> _Nullable delegate;
/// The back button in the top left corner of this controller.
@property (nonatomic, readonly, strong) IBOutlet UIButton * _Null_unspecified backButton;
/// The Next button in the top right corner of this controller.
@property (nonatomic, readonly, strong) IBOutlet UIButton * _Null_unspecified nextButton;
/// When “Keep Draft” is pressed in the save dialogue, no action is taken since the session has already been automatically saved.
/// When “Discard” is pressed in the save dialogue, the session is destroyed by calling <code>Session.destroy()</code>.
/// If this is true, the controller may show the save dialogue when the back button is pressed.
/// <code>Session.isTransient</code> must be false and there must have been changes to the session for a save dialogue to appear.
/// If this is false, no save dialogue will be shown when the back button button is pressed.
/// For all cases where no save dialogue appears, the session will stay saved and <code>Session.destroy()</code> will not be called.
/// Default value: <code>true</code>
@property (nonatomic) BOOL showsSaveDialogue;
/// If you would like to disable cropping, rotation and horizontal/vertical perspective correction set this to false.
/// This will hide the Position button found in the Adjust tab.
/// Default value: <code>true</code>
@property (nonatomic) BOOL showsPositionAdjustment;
/// Set this to true if you want to reduce the height of the editor controls and increase the height of the media preview. This can improve the user experience if portrait content is edited frequently.
/// If this controller is presented by a <code>LibraryController</code> or <code>CameraController</code> with a portrait aspect ratio, the default value may be <code>true</code> instead of <code>false</code>.
/// Default value: <code>false</code>
@property (nonatomic) BOOL compactControls;
/// :nodoc:
- (void)viewDidLoad;
/// :nodoc:
- (void)viewDidLayoutSubviews;
/// :nodoc:
- (void)viewWillAppear:(BOOL)animated;
/// :nodoc:
- (void)viewDidAppear:(BOOL)animated;
/// :nodoc:
- (void)viewWillDisappear:(BOOL)animated;
/// :nodoc:
- (void)viewDidDisappear:(BOOL)animated;
/// :nodoc:
- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
- (void)willTransitionToTraitCollection:(UITraitCollection * _Nonnull)newCollection withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
@property (nonatomic, readonly) UIInterfaceOrientationMask supportedInterfaceOrientations;
/// :nodoc:
@property (nonatomic, readonly) BOOL prefersStatusBarHidden;
/// :nodoc:
@property (nonatomic, readonly) UIStatusBarStyle preferredStatusBarStyle;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end



@interface EditController (SWIFT_EXTENSION(PixelSDK))
/// :nodoc:
@property (nonatomic, readonly, strong) UIView * _Nullable preferredTopBarView;
/// :nodoc:
- (void)setNeedsTopBarAppearanceUpdate;
@end





@interface EditController (SWIFT_EXTENSION(PixelSDK))
@property (nonatomic, readonly) BOOL prefersBottomBarHidden;
@property (nonatomic, readonly, strong) UIView * _Nullable preferredBottomBarView;
- (void)setNeedsBottomBarAppearanceUpdate;
@end



/// Use this delegate to handle events that occur in the <code>EditController</code>.
SWIFT_PROTOCOL("_TtP8PixelSDK22EditControllerDelegate_")
@protocol EditControllerDelegate
@optional
/// This will be called after <code>EditController</code> viewDidLoad. This will only be called once per <code>EditController</code>.
/// \param editController The controller responsible for calling this method.
///
/// \param session The session the editController will be editing.
///
- (void)editController:(EditController * _Nonnull)editController didLoadEditing:(Session * _Nonnull)session;
/// This will be called at the end of <code>EditController</code> viewWillAppear.
/// \param editController The controller responsible for calling this method.
///
/// \param session The session the editController will be editing.
///
- (void)editController:(EditController * _Nonnull)editController willBeginEditing:(Session * _Nonnull)session;
/// This will be called at the end of <code>EditController</code> viewDidAppear.
/// \param editController The controller responsible for calling this method.
///
/// \param session The session the editController will be editing.
///
- (void)editController:(EditController * _Nonnull)editController didBeginEditing:(Session * _Nonnull)session;
@required
/// This will be called when the Next button is pressed. You should push on a new controller to the navigation stack or dismiss the controller here.
/// attention:
/// You are responsible for destroying the provided session if you do not want it to persist.
/// \param editController The controller responsible for calling this method.
///
/// \param session The session the controller has finished editing.
///
- (void)editController:(EditController * _Nonnull)editController didFinishEditing:(Session * _Nonnull)session;
@optional
/// This will be called when the back button is pressed. If a save dialogue gets presented, this will be called after the dialogue has been dismissed.
/// \param editController The controller responsible for calling this method.
///
/// \param session The session the controller has cancelled editing. If the session was not destroyed by the <code>EditController</code> it will be passed here. To understand when a session will be destroyed see <code>EditController.showsSaveDialogue</code> for more information. If the <code>EditController</code> was shown by a <code>CameraController</code> and you destroy the session it will lead to undocumented behavior since the camera depends on the session.
///
- (void)editController:(EditController * _Nonnull)editController didCancelEditing:(Session * _Nullable)session;
@end

@protocol LibraryControllerDelegate;
@class NSPredicate;
@class UIActivityIndicatorView;
@class PreviewCropController;

/// The <code>LibraryController</code> offers a way to quickly select and crop images or videos from the users Photo Library. Users can switch between regular albums, smart albums, iCloud albums, or albums imported directly from a DSLR camera. In addition, there is a separate section for selecting and deleting drafts.
/// <em>Figure 1</em> Library controller
/// <img src="https://www.cdn.pixelsdk.com/assets/img/screenshots/sdk/library_1.jpg" alt="Screenshot" width="190" height="auto" style="border-style: solid; border-width: 1px; border-color: LightGrey;"/>
/// This controller is used inside the <code>ContainerController</code> and can be used on its own by initializing
/// the container controller with only one mode <code>.library</code>.
/// For more information on modifying the cropping behavior of the library controller see its <code>PreviewCropController</code>.
/// The library controller can also be restricted to only display certain types of media. For example images only:
/// \code
/// containerController.libraryController.fetchPredicate = NSPredicate(format: "mediaType == %d", PHAssetMediaType.image.rawValue)
/// containerController.libraryController.draftMediaTypes = [.image]
///
/// \endcodeBy default, the library controller pushes an <code>EditController</code> onto the navigation stack when the Next button is pressed. This can be disabled by setting <code>showsEditControllerWhenDone</code> to false. You will also need to implement the <code>LibraryControllerDelegate</code> in order to respond the <code>LibraryControllerDelegate.libraryController(_:didFinishWithSession:withSegment:)</code> delegate method.
SWIFT_CLASS("_TtC8PixelSDK17LibraryController")
@interface LibraryController : UIViewController
/// Set this delegate in order to handle events that occur in this controller.
/// Default value: <code>nil</code>
@property (nonatomic, weak) id <LibraryControllerDelegate> _Nullable delegate;
/// Set this to false if you do not want the <code>EditController</code> pushed onto the navigation stack
/// after the user presses the Next button.
/// You can push your own controller or dismiss this controller in the <code>LibraryControllerDelegate.libraryController(_:didFinishWithSession:withSegment:)</code> delegate method.
/// Default value: <code>true</code>
@property (nonatomic) BOOL showsEditControllerWhenDone;
/// Set this if you need to restrict the users Photo Library to a certain type of media.
/// Only images for example:
/// \code
/// libraryController.fetchPredicate = NSPredicate(format: "mediaType == %d", PHAssetMediaType.image.rawValue)
///
/// \endcodeDefault value: <code>nil</code>
@property (nonatomic, strong) NSPredicate * _Nullable fetchPredicate;
/// When false, each video draft will appear as one draft.
/// When true, each video draft will be displayed as individual segments. For example, if a video has 3 segments the draft will instead appear as 3 separate drafts.
/// Default value: <code>false</code>
@property (nonatomic) BOOL splitVideoDraftsIntoSegments;
/// The Cancel button in the top left corner of this controller.
@property (nonatomic, readonly, strong) IBOutlet UIButton * _Null_unspecified cancelButton;
/// The Next button in the top right corner of this controller.
@property (nonatomic, readonly, strong) IBOutlet UIButton * _Null_unspecified nextButton;
/// This activity indicator may briefly appear in place of the <code>nextButton</code> after it is pressed.
@property (nonatomic, readonly, strong) IBOutlet UIActivityIndicatorView * _Null_unspecified activityIndicatorView;
/// This is the square preview controller at the top of this controller responsible for displaying and cropping media.
/// Use this to customize cropping behavior.
@property (nonatomic, readonly, strong) PreviewCropController * _Nonnull previewCropController;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// :nodoc:
- (void)viewDidLoad;
/// :nodoc:
- (void)viewWillLayoutSubviews;
/// :nodoc:
- (void)viewWillAppear:(BOOL)animated;
/// :nodoc:
- (void)viewDidAppear:(BOOL)animated;
/// :nodoc:
- (void)viewWillDisappear:(BOOL)animated;
/// :nodoc:
- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
- (void)willTransitionToTraitCollection:(UITraitCollection * _Nonnull)newCollection withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
@property (nonatomic, readonly) UIStatusBarStyle preferredStatusBarStyle;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end


@class UIGestureRecognizer;

@interface LibraryController (SWIFT_EXTENSION(PixelSDK)) <UIGestureRecognizerDelegate>
- (BOOL)gestureRecognizer:(UIGestureRecognizer * _Nonnull)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer * _Nonnull)otherGestureRecognizer SWIFT_WARN_UNUSED_RESULT;
@end



@interface LibraryController (SWIFT_EXTENSION(PixelSDK))
@property (nonatomic, readonly) BOOL prefersBottomBarHidden;
@end







@class SessionVideoSegment;

/// Use this delegate to handle events that occur in the <code>LibraryController</code>.
SWIFT_PROTOCOL("_TtP8PixelSDK25LibraryControllerDelegate_")
@protocol LibraryControllerDelegate
@optional
/// This will be called when the Cancel button is pressed.
/// \param libraryController The controller responsible for calling this method.
///
- (void)libraryControllerDidCancel:(LibraryController * _Nonnull)libraryController;
/// This will be called when the Next button is pressed.
/// \param libraryController The controller responsible for calling this method.
///
/// \param session The session that was generated by the <code>LibraryController</code>.
/// If <code>showsEditControllerWhenDone</code> is false, you are responsible for destroying the session if you do not want it to persist.
/// If it is true, destroying the session will result in undocumented behavior.
///
/// \param segment This will be passed if the user selected a specific segment from the session.
/// This will only happen if <code>splitVideoDraftsIntoSegments</code> is true.
///
- (void)libraryController:(LibraryController * _Nonnull)libraryController didFinishWithSession:(Session * _Nonnull)session withSegment:(SessionVideoSegment * _Nullable)segment;
/// This will be called when the Next button is pressed and <code>showsEditControllerWhenDone</code> is true.
/// If you wish to make any additional customizations to the ‘EditController’ before it is pushed, you may do so here.
/// \param libraryController The controller responsible for calling this method.
///
/// \param editController The new <code>EditController</code> that will be pushed onto the navigation stack.
///
/// \param session The session that was generated by the <code>LibraryController</code> and will be
/// passed to the <code>EditController</code>. Destroying the session will result in undocumented behavior.
///
- (void)libraryController:(LibraryController * _Nonnull)libraryController willShowEditController:(EditController * _Nonnull)editController withSession:(Session * _Nonnull)session;
@end




@protocol PreviewControllerDelegate;

/// Preview controllers let you draw any image or video based <code>Session</code> object.
/// For example, you can use the <code>PreviewController</code> class to display the contents of a session found in the <code>SessionManager.savedSessions</code> array (user Drafts) or even a <code>Session</code> you have just initialized. You configure a preview controller programmatically by adding its view as a subview to the view of your choosing. For video, you can also use methods of this class to start or stop the video and specify other playback parameters.
/// The preview controller will also display <a href="https://www.pixelsdk.com/docs/latest/Classes/Session.html#modifying-sessions">programmatic edits</a> that are made on a session in real-time.
/// <em>Figure 1</em> Preview controller
/// <img src="https://www.cdn.pixelsdk.com/assets/img/docs/filter_original.jpg" alt="Preview controller" title="Preview controller" width="250" height="auto"/>
/// A preview controller uses the <code>contentMode</code> variable and the size of the media itself to determine how to display the media. The preview controller can scale your media to fit all or some of the available space. If the size of the preview controller changes, it automatically scales the media as needed.
/// The presentation of the media is determined by the preview controllers <code>contentMode</code> property. The <code>ContentMode.contentAspectFit</code> and <code>ContentMode.contentAspectFill</code> values scale the media to fit or fill the space while maintaining the media’s original aspect ratio. The <code>ContentMode.contentFill</code> value scales the media without regard to the original aspect ratio, which can cause the media to appear distorted.
/// The below example creates a preview controller, adds it as a child of your controller and as a subview of your view.
/// It then anchors the preview controller 30 points from the left of your view and 100 points from the top of your view.
/// The preview controller is also given a height of 200 points and a width of 200 points.
/// \code
/// override func viewDidLoad() {
///     super.viewDidLoad()
///
///     let controller = PreviewController()
///     self.addChild(controller)
///     self.view.addSubview(controller.view)
///
///     controller.view.translatesAutoresizingMaskIntoConstraints = false
///     controller.view.leftAnchor.constraint(equalTo: self.view.leftAnchor, constant: 30).isActive = true
///     controller.view.topAnchor.constraint(equalTo: self.view.topAnchor, constant: 100).isActive = true
///     controller.view.heightAnchor.constraint(equalToConstant: 200).isActive = true
///     controller.view.widthAnchor.constraint(equalToConstant: 200).isActive = true
///
///     controller.session = <#Your Session#>
/// }
///
/// \endcode
SWIFT_CLASS("_TtC8PixelSDK17PreviewController")
@interface PreviewController : UIViewController
/// Creates a <code>PreviewController</code>.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// Set this delegate if you want to make changes to the preview controller view layout
/// using the size of the media before or after it has appeared.
/// Default value: <code>nil</code>
@property (nonatomic, weak) id <PreviewControllerDelegate> _Nullable delegate;
/// :nodoc:
- (void)viewDidLoad;
/// :nodoc:
- (void)viewWillDisappear:(BOOL)animated;
/// :nodoc:
- (void)viewDidDisappear:(BOOL)animated;
/// :nodoc:
- (void)viewWillAppear:(BOOL)animated;
/// :nodoc:
- (void)viewDidAppear:(BOOL)animated;
/// :nodoc:
- (void)didReceiveMemoryWarning;
/// The session to be displayed by the preview controller.
/// All changes made to the session (changing filters, trim times, preferredTransform, etc.) will be automatically displayed by the preview controller in real-time.
/// Default value: <code>nil</code>
@property (nonatomic, strong) Session * _Nullable session;
/// The preview controller uses the <code>contentMode</code> variable and the size of the media itself to determine how to display the media. The preview controller can scale your media to fit all or some of the available space.
/// The <code>ContentMode.contentAspectFit</code> and <code>ContentMode.contentAspectFill</code> values scale the media to fit or fill the space while maintaining the media’s original aspect ratio.
/// The <code>ContentMode.contentFill</code> value scales the media without regard to the original aspect ratio, which can cause the media to appear distorted.
/// Default value: <code>.contentAspectFit</code>
@property (nonatomic) enum ContentMode contentMode;
/// Controls whether or not the video should loop.
/// Default value: <code>true</code>
@property (nonatomic) BOOL loops;
/// Controls whether or not the video is muted.
/// Key value observable.
/// Default value: <code>false</code>
@property (nonatomic) BOOL isMuted;
/// The current time of the video playback.
/// Default value: <code>.zero</code>
@property (nonatomic, readonly) CMTime currentTime;
/// When true, the video will automatically start playing after the <code>session</code> variable is set.
/// Default value: <code>true</code>
@property (nonatomic) BOOL autoplayEnabled;
/// Indicates if the video is currently playing. The video may still be loading when this is true.
/// Default value: <code>false</code>
@property (nonatomic, readonly) BOOL isPlaying;
/// Begins playback of the video.
/// Immediately after this is called, <code>isPlaying</code> will be true.
- (void)play;
/// Pauses playback of the video.
/// Immediately after this is called, <code>isPlaying</code> will be false.
- (void)pause;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end



/// Set this delegate if you want to make changes to the <code>PreviewController</code> view layout
/// using the size of the media before or after it has appeared.
SWIFT_PROTOCOL("_TtP8PixelSDK25PreviewControllerDelegate_")
@protocol PreviewControllerDelegate
/// Called before the <code>PreviewController</code> has displayed the media. Use this time to handle any additional layout for the view.
/// \param previewController The controller responsible for calling this method.
///
/// \param size The actual size of the media. This is not the size in points of the media on the screen.
///
- (void)previewControllerWillDisplayMedia:(PreviewController * _Nonnull)previewController withSize:(CGSize)size;
/// Called after the <code>PreviewController</code> has displayed the media.
/// \param previewController The controller responsible for calling this method.
///
/// \param size The actual size of the media. This is not the size in points of the media on the screen.
///
- (void)previewControllerDidDisplayMedia:(PreviewController * _Nonnull)previewController withSize:(CGSize)size;
@end

@class UITouch;
@class UIEvent;

/// The <code>PreviewCropController</code> handles cropping for media in the <code>LibraryController</code>.
/// <em>Figure 1</em> Preview crop controller
/// <img src="https://www.cdn.pixelsdk.com/assets/img/docs/crop_controller.jpg" alt="Preview crop controller" title="Preview crop controller" width="250" height="auto"/>
/// The crop controller can be accessed with the following:
/// \code
/// let cropController = containerController.libraryController.previewCropController
///
/// \endcodeThe below examples demonstrate a few custom variations in cropping behavior.
/// Allow only content of a specific aspect ratio. For example square content only:
/// \code
/// cropController.aspectRatio = CGSize(width: 1, height: 1)
///
/// \endcodeAllow only content of a maximum aspect ratio. This is the default functionality.
/// \code
/// cropController.maxRatioForPortraitMedia = CGSize(width: 3, height: 4)
/// cropController.maxRatioForLandscapeMedia = CGSize(width: 16, height: 9)
///
/// \endcodeSet content initially zoomed in or out. For example initially zoomed out:
/// \code
/// cropController.defaultsToAspectFillForPortraitMedia = false
/// cropController.defaultsToAspectFillForLandscapeMedia = false
///
/// \endcodeApply no initial cropping, unless the user interacts with the cropper:
/// \code
/// cropController.maxRatioForPortraitMedia = CGSize(width: 1, height: .max)
/// cropController.maxRatioForLandscapeMedia = CGSize(width: .max, height: 1)
///
/// cropController.defaultsToAspectFillForPortraitMedia = false
/// cropController.defaultsToAspectFillForLandscapeMedia = false
///
/// \endcodeDisable cropping from user interaction:
/// \code
/// cropController.userInteractionEnabled = false
///
/// \endcodeIf the last two examples are combined, cropping will be disabled entirely.
SWIFT_CLASS("_TtC8PixelSDK21PreviewCropController")
@interface PreviewCropController : UIViewController
/// If this is true when portrait media is loaded into the crop controller, the media will by default be zoomed in to fill the crop controller and if false it will by default be zoomed out.
/// Setting this to true will bias the user to produce square content and false will bias them to produce portrait content.
/// If media has already loaded in, you must call <code>layoutMedia()</code> after setting this for an immediate effect.
/// attention:
/// This variable has no effect if <code>aspectRatio</code> is set.
/// Default value: <code>true</code>
@property (nonatomic) BOOL defaultsToAspectFillForPortraitMedia;
/// If this is true when landscape media is loaded into the crop controller, the media will by default be zoomed in to fill the crop controller and if false it will by default be zoomed out.
/// Setting this to true will bias the user to produce square content and false will bias them to produce landscape content.
/// If media has already loaded in, you must call <code>layoutMedia()</code> after setting this for an immediate effect.
/// attention:
/// This variable has no effect if <code>aspectRatio</code> is set.
/// Default value: <code>true</code>
@property (nonatomic) BOOL defaultsToAspectFillForLandscapeMedia;
/// Call this function if you want to briefly flash the grid lines.
- (void)flashGridLines;
/// This ratio is the maximum amount of content that can be visible when portrait media is zoomed all the way out.
/// If media has already loaded in, you must call <code>layoutMedia()</code> after setting this for an immediate effect.
/// attention:
/// This variable has no effect if <code>aspectRatio</code> is set.
/// precondition:
/// Size width must be less than size height.
/// Default value: <code>CGSize(width: 3, height: 4)</code>
@property (nonatomic) CGSize maxRatioForPortraitMedia;
/// This ratio is the maximum amount of content that can be visible when landscape media is zoomed all the way out.
/// If media has already loaded in, you must call <code>layoutMedia()</code> after setting this for an immediate effect.
/// attention:
/// This variable has no effect if <code>aspectRatio</code> is set.
/// precondition:
/// Size width must be greater than size height.
/// Default value: <code>CGSize(width: 16, height: 9)</code>
@property (nonatomic) CGSize maxRatioForLandscapeMedia;
/// Controls whether cropping is enabled.
/// Default: <code>true</code>
@property (nonatomic) BOOL userInteractionEnabled;
/// Controls whether video media should be paused when the user is dragging it in the crop controller.
/// Default value: <code>true</code>
@property (nonatomic) BOOL pausesVideoOnDrag;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// :nodoc:
- (void)viewDidLoad;
/// :nodoc:
- (void)viewWillAppear:(BOOL)animated;
/// :nodoc:
- (void)viewWillLayoutSubviews;
/// :nodoc:
- (void)viewDidLayoutSubviews;
/// :nodoc:
- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
- (void)touchesBegan:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
/// :nodoc:
- (void)touchesEnded:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
/// :nodoc:
- (void)touchesCancelled:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
/// This will layout the media again and reset its position.
- (void)layoutMedia;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end


@interface PreviewCropController (SWIFT_EXTENSION(PixelSDK)) <PreviewControllerDelegate>
- (void)previewControllerWillDisplayMedia:(PreviewController * _Nonnull)previewController withSize:(CGSize)size;
- (void)previewControllerDidDisplayMedia:(PreviewController * _Nonnull)previewController withSize:(CGSize)size;
@end

@class UIScrollView;

@interface PreviewCropController (SWIFT_EXTENSION(PixelSDK)) <UIScrollViewDelegate>
- (UIView * _Nullable)viewForZoomingInScrollView:(UIScrollView * _Nonnull)scrollView SWIFT_WARN_UNUSED_RESULT;
- (void)scrollViewDidScroll:(UIScrollView * _Nonnull)scrollView;
- (void)scrollViewWillBeginDragging:(UIScrollView * _Nonnull)scrollView;
- (void)scrollViewDidEndDragging:(UIScrollView * _Nonnull)scrollView willDecelerate:(BOOL)decelerate;
- (void)scrollViewDidEndDecelerating:(UIScrollView * _Nonnull)scrollView;
- (void)scrollViewDidZoom:(UIScrollView * _Nonnull)scrollView;
- (void)scrollViewWillBeginZooming:(UIScrollView * _Nonnull)scrollView withView:(UIView * _Nullable)view;
- (void)scrollViewDidEndZooming:(UIScrollView * _Nonnull)scrollView withView:(UIView * _Nullable)view atScale:(CGFloat)scale;
@end

@class UIImage;
@class SessionImage;
@class SessionVideo;
@class NSDate;

/// <h3>Overview</h3>
/// A <code>Session</code> is analogous to a project in photo and video editing software. A session can contain either a <code>SessionImage</code> or <code>SessionVideo</code> composed of one or more <code>SessionVideoSegment</code> objects. Sessions are mutable and store all information related to the rendering of their media including files, crop rects, filters, trim times, etc. They also contain metadata like modification time, userInfo, and latitude/longitude.
/// You can use session objects in several different ways:
/// <ul>
///   <li>
///     Assign a session to a <code>PreviewController</code> object to display the session in your interface.
///   </li>
///   <li>
///     Initialize an <code>EditController</code> with a session so you can make edits visually.
///   </li>
///   <li>
///     Programmatically make real-time modifications to a session like set filters, crop rects, segment trim times, etc.
///   </li>
/// </ul>
/// <h3>Creating Session Objects</h3>
/// When creating session objects using the methods of this class, you must have an existing image or video located in a file, UIImage, or local AVAsset. You cannot create an empty session and later add media. There are a couple options for creating session objects, each of which is best for specific situations:
/// <ul>
///   <li>
///     <code>init(image:)</code> creates a session with the provided UIImage.
///   </li>
///   <li>
///     <code>init(asset:sessionReady:)</code> creates a session with the provided AVAsset.
///   </li>
///   <li>
///     <code>init(assets:sessionReady:)</code> creates a session with the provided AVAssets where each asset corresponds to a segment in the session video.
///   </li>
///   <li>
///     <code>init(assets:renderSize:sessionReady:)</code> creates a session of a specific pixel dimension and with the provided AVAssets where each asset corresponds to a segment in the session video.
///   </li>
/// </ul>
/// After a session is successfully created you may delete any local image/video files that you used to create the session.
/// <h3>Saving/Restoring Sessions</h3>
/// By default, all sessions are automatically saved to file and accessible from the users Drafts in the <code>LibraryController</code> and the <code>SessionManager.savedSessions</code> array. If you do not want a session to persist in memory and on disk, you should call <code>destroy()</code> when the session is no longer needed. No further action is required on your part.
/// If you want to know how to retrieve a saved session on startup see <code>SessionManager</code> for more information.
/// <h3>Modifying Sessions</h3>
/// Sessions can also be edited programmatically instead of visually.
/// For example, setting the primaryFilter of an image to <a href="https://www.pixelsdk.com/docs/latest/Classes/SessionFilterWilshire.html">Wilshire</a>:
/// \code
/// session.image!.primaryFilter = SessionFilterWilshire()
///
/// \endcodeApplying a <a href="https://www.pixelsdk.com/docs/latest/Classes/SessionFilterBrightness.html">Brightness</a> filter to an image:
/// \code
/// let brightnessFilter = SessionFilterBrightness()
/// brightnessFilter.normalizedIntensity = 0.2
/// session.image!.filters = [brightnessFilter]
///
/// \endcodeApplying a <a href="https://www.pixelsdk.com/docs/latest/Classes/SessionFilterSaturation.html">Saturation</a> filter to a whole video:
/// \code
/// let saturationFilter = SessionFilterSaturation()
/// saturationFilter.normalizedIntensity = 0.3
/// session.video!.filters = [saturationFilter]
///
/// \endcodeApplying a <a href="https://www.pixelsdk.com/docs/latest/Classes/SessionFilterContrast.html">Contrast</a> filter to the first segment of a video:
/// \code
/// let segment = session.video!.videoSegments.first!
/// let contrastFilter = SessionFilterContrast()
/// contrastFilter.normalizedIntensity = 0.2
/// segment.filters = [contrastFilter]
///
/// \endcodeTrimming a segment so it <a href="https://www.pixelsdk.com/docs/latest/Classes/SessionVideoSegment.html#/c:@M@PixelSDK@objc(cs)SessionVideoSegment(py)trimStartTime">starts</a> at one second in, with a <a href="https://www.pixelsdk.com/docs/latest/Classes/SessionVideoSegment.html#/c:@M@PixelSDK@objc(cs)SessionVideoSegment(py)trimDuration">duration</a> of two seconds:
/// \code
/// let segment = session.video!.videoSegments.first!
/// segment.trimStartTime = CMTime(seconds: 1, preferredTimescale: segment.duration.timescale)
/// segment.trimDuration = CMTime(seconds: 2, preferredTimescale: segment.duration.timescale)
///
/// \endcodeRotating the first segment of a video with <a href="https://www.pixelsdk.com/docs/latest/Classes/SessionVideoSegment.html#/c:@M@PixelSDK@objc(cs)SessionVideoSegment(py)preferredTransform">preferredTransform</a>:
/// \code
/// let segment = session.video!.videoSegments.first!
/// segment.preferredTransform = .rotated180Degrees(segment.naturalSize)
/// segment.cropRect = segment.suggestedCropRect()
///
/// \endcodeIncreasing the <a href="https://www.pixelsdk.com/docs/latest/Classes/SessionVideoSegment.html#/c:@M@PixelSDK@objc(cs)SessionVideoSegment(py)speedMultiplier">speed</a> of the first segment of a video:
/// \code
/// let segment = session.video!.videoSegments.first!
/// segment.speedMultiplier = 2 // 2x faster
///
/// \endcodeYou can present the <code>EditController</code> after making programmatic edits and it will reflect your changes. Additionally, the <code>PreviewController</code> will reflect all programmatic edits in real-time.
/// After making programmatic edits to a session, you should manually call <code>session.save()</code>.
/// warning:
/// If you make programmatic changes to a session that is currently displayed by an <code>EditController</code> it may result in undocumented behavior.
/// <h3>Exporting Session Media</h3>
/// See the <code>VideoExporter</code> and <code>ImageExporter</code> classes.
/// If you need to retrieve thumbnails for media, you can do so with the <code>SessionImage</code> and <code>SessionVideoSegment</code>  <code>requestThumbnail()</code> functions respectively.
SWIFT_CLASS("_TtC8PixelSDK7Session")
@interface Session : NSObject
/// Creates a <code>Session</code> with the provided image.
/// \param image The image to create the session with.
///
- (nonnull instancetype)initWithImage:(UIImage * _Nonnull)image;
/// An image associated with the session, if any.
/// A session will have either a video or image associated with it, but never both.
@property (nonatomic, readonly, strong) SessionImage * _Nullable image;
/// A video associated with the session, if any.
/// A session will have either a video or image associated with it, but never both.
@property (nonatomic, readonly, strong) SessionVideo * _Nullable video;
/// A unique ID assigned to this session.
@property (nonatomic, readonly) NSInteger sessionID;
/// UTC Date created, set when the session is first initialized.
@property (nonatomic, readonly, copy) NSDate * _Nonnull dateCreated;
/// UTC Date modified, set when the session is saved.
@property (nonatomic, readonly, copy) NSDate * _Nonnull dateModified;
/// Set this to any information you want associated with this session.
/// The SDK will handle calling <code>save()</code> after you set this.
/// Must be a valid JSON object. https://developer.apple.com/documentation/foundation/jsonserialization/1418461-isvalidjsonobject
/// Default value: <code>nil</code>
@property (nonatomic, copy) NSDictionary * _Nullable userInfo;
/// If the session can be found in the <code>SessionManager.savedSessions</code> array this will be true.
@property (nonatomic, readonly) BOOL isSaved;
/// If the session should never be saved, written to file or the <code>SessionManager.savedSessions</code> array, set this to true.
/// This is helpful if you need a temporary session that can be easily thrown away.
/// Anything that is written to file for this session (e.g. video files) will be deleted on next restart if you do not call <code>destroy()</code> before then. If you are creating many temporary sessions, make sure to call <code>destroy()</code> when done with a session to prevent memory or disk space from running out.
/// Default value: <code>false</code>
@property (nonatomic) BOOL isTransient;
/// Indicates if <code>destroy()</code> has been called on the session.
/// Default value: <code>false</code>
@property (nonatomic, readonly) BOOL destroyed;
/// Set this to true if you do not want this session to appear in Drafts on the <code>LibraryController</code>.
/// warning:
/// Improper usage of this may lead to runaway growth of <code>SessionManager.savedSessions</code> array
/// and disk usage since all sessions are automatically saved. You may be unaware that the session still
/// exists since it will not be visible in your Drafts.
/// Default value: <code>false</code>
@property (nonatomic) BOOL hidden;
/// The SDK automatically saves every <code>Session</code> that interacts with a view controller (<code>EditController</code>, <code>LibraryController</code>, <code>CameraController</code>) so you should not need to call this.
/// You should only call this when you have finished making a set of programmatic changes to a session.
/// When a session is saved it will be written to file and inserted into the <code>SessionManager.savedSessions</code> array (if not already present). It will also appear in the users Drafts on the <code>LibraryController</code>.
/// Every variable in the session will be saved, unless the documentation for a specific variable explicitly states:
/// “Does not persist.”
/// precondition:
/// <code>isTransient</code> and <code>destroyed</code> must be false for a session to successfully save.
- (void)save;
/// Sessions are automatically saved so you a responsible for calling this when you are done with a session (unless noted otherwise). If you do not destroy a session it will persist in the users Drafts in memory and on disk.
/// A documentation example of where a session should not be destroyed is in the <code>ContainerControllerDelegate.containerController(_:willShowEditController:withSession:)</code> delegate call.
/// This deletes all files associated with a session (videos, images, etc.), removes it from the <code>SessionManager.savedSessions</code> array and sets the <code>destroyed</code> variable to true.
/// After calling this, the session can no longer be used and you should begin releasing all references to it.
- (void)destroy;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CLLocation;
@class NSURL;

/// For more information see <code>Session</code> documentation.
SWIFT_CLASS("_TtC8PixelSDK12SessionImage")
@interface SessionImage : NSObject
/// The pixel dimensions of the original image. Does not take into account the preferredTransform.
@property (nonatomic, readonly) CGSize naturalSize;
/// The pixel dimensions of the original image with the preferredTransform taken into account.
@property (nonatomic, readonly) CGSize actualSize;
/// The pixel dimensions of the final image.
/// If there is a cropRect, this will be equal to the size of the cropRect. Otherwise it is equal to the actualSize.
@property (nonatomic, readonly) CGSize renderSize;
/// The preferredTransform takes into account any rotation that should be made to the image.
/// If the image originally came with an orientation, it will be converted into the preferredTransform.
/// Any rotation made by the <code>EditController</code> will also be reflected here.
/// Default value: <code>.identity</code>
@property (nonatomic) CGAffineTransform preferredTransform;
/// If the image came from the users Photo Library and there was location information associated, this will be set.
/// See the <a href="https://developer.apple.com/documentation/corelocation/cllocation">documentation</a> for CLLocation.
/// Default value: <code>nil</code>
@property (nonatomic, strong) CLLocation * _Nullable location;
/// The URL location of the final JPEG image file after it has been exported. There will only be a file here after an export has been completed. You may move, copy or delete this file. See <code>ImageExporter</code> for more information.
@property (nonatomic, readonly, copy) NSURL * _Nonnull exportedImageURL;
/// The UTC date when the last successful image export started.
@property (nonatomic, readonly, copy) NSDate * _Nullable dateExported;
/// Indicates if the export was completed.
/// If the sessions dateModified is an older date than the images dateExported, this will be false. In other words, if you export the image this will become true but if you then make modifications to the image this will flip back to false. The exportedImageURL file must also exist for this to be true.
@property (nonatomic, readonly) BOOL isExported;
/// Clears the thumbnail cache.
- (void)invalidateThumbnails;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// By default, all sessions are automatically saved to file and accessible from the users Drafts in the <code>LibraryController</code> and the <code>savedSessions</code> array.
/// The <code>SessionManager</code> is responsible for automatically restoring saved sessions when the application starts. The <code>savedSessions</code> array will be populated and the <code>DidRestoreSavedSessionsNotification</code> will be called when the session manager has finished restoring the sessions. If you are accessing the <code>savedSessions</code> array and displaying its contents you should refresh your UI when the notification is posted.
/// You must call <code>PixelSDK.setup()</code> from your App Delegate to guarantee the <code>savedSessions</code> array is populated when the application starts, otherwise we will attempt to populate it at a later point.
/// <h3>Retrieving a Session</h3>
/// If you want to retrieve a specific session after your application restarts, simply save its <code>sessionID</code> beforehand. You can save it in user defaults or your own data structure. For example with user defaults:
/// \code
/// let savedSessionID = session.sessionID
/// UserDefaults.standard.set(savedSessionID, forKey: "mySessionID")
///
/// \endcodeAnd then at a later point (after a restart, etc.) you can retrieve the session using the ID you saved:
/// \code
/// if let savedSessionID = UserDefaults.standard.object(forKey: "mySessionID") as? Int,
///     let session = SessionManager.shared.savedSessions.first { $0.sessionID == savedSessionID } {
///     // Retrieved session!
/// }
///
/// \endcodeAll sessions are automatically saved, so you only need to worry about saving the <code>sessionID</code> and retrieving the session from the <code>savedSessions</code> array. If you destroy the session or delete the session from your drafts, you will no longer be able to retrieve the session.
/// Another option for retrieving a session is to simply set some identifying <code>userInfo</code> on the session beforehand.
/// For example:
/// \code
/// session.userInfo = ["my_internal_id": 2]
///
/// \endcodeAnd then at a later point (after a restart, etc.) you can retrieve the session by finding the session with your user info:
/// \code
/// for session in SessionManager.shared.savedSessions {
///     if let myInternalID = session.userInfo?["my_internal_id"] as? Int,
///         myInternalID == 2 {
///         // Retrieved session!
///     }
/// }
///
/// \endcode
SWIFT_CLASS("_TtC8PixelSDK14SessionManager")
@interface SessionManager : NSObject
/// Use this to access the shared instance of the <code>SessionManager</code>.
/// For example to access the saved sessions:
/// \code
/// print("Saved Sessions: \(SessionManager.shared.savedSessions)")
///
/// \endcode
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) SessionManager * _Nonnull shared;)
+ (SessionManager * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// This array contains all sessions that have been saved. The contents of this array will be displayed as the Drafts section of the <code>LibraryController</code>. If a session is deleted from Drafts or <a href="https://www.pixelsdk.com/docs/latest/Classes/Session.html#/c:@M@PixelSDK@objc(cs)Session(im)destroy">destroyed</a> it will be removed from this array.
/// For example to access the saved sessions:
/// \code
/// print("Saved Sessions: \(SessionManager.shared.savedSessions)")
///
/// \endcode
@property (nonatomic, readonly, copy) NSArray<Session *> * _Nonnull savedSessions;
/// This will be true after the <code>savedSessions</code> array has been populated. This will be set to true shortly after the application starts.
/// Default value: <code>false</code>
@property (nonatomic, readonly) BOOL didRestoreSavedSessions;
/// This notification will be posted to the default NotificationCenter from the main thread after the <code>savedSessions</code> array has been populated. This will happen shortly after the application starts.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull DidRestoreSavedSessionsNotification;)
+ (NSNotificationName _Nonnull)DidRestoreSavedSessionsNotification SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// For more information see <code>Session</code> documentation.
SWIFT_CLASS("_TtC8PixelSDK12SessionVideo")
@interface SessionVideo : NSObject
/// The pixel dimensions of the final video.
/// If not manually set, this will be equal to the size of the cropRect of the first segment. If there is no cropRect, it is equal to the actualSize of the first segment. If the first segment later changes, the renderSize will not also change.
/// If you manually change the renderSize, you will need to update the cropRect for each segment if the renderSize width/height ratio has changed. You can avoid this by setting the <code>CameraController</code> <code>CameraController.aspectRatio</code> and <code>PreviewCropController</code> <code>PreviewCropController.aspectRatio</code> beforehand.
/// If you provide floating point numbers, they will be rounded using the Drawin.round() function.
/// If you provide odd numbers, they will be reduced to the next lower even number, e.g. 5 becomes 4. This is because AVFoundation can’t handle odd pixel dimensions when writing video files and will instead substitute in a green line.
@property (nonatomic) CGSize renderSize;
/// The video segments in the video.
/// precondition:
/// There must be one or more videoSegments.
@property (nonatomic, readonly, copy) NSArray<SessionVideoSegment *> * _Nonnull videoSegments;
/// The total duration of the video.
/// Calculated by adding the <code>SessionVideoSegment.renderDuration</code> of every segment together.
@property (nonatomic, readonly) CMTime duration;
/// The framerate for the video.
/// For example, a frameDuration of 1/30th of a second <code>CMTime(value: 1, timescale: 30)</code> would be a 30fps video.
/// If not manually set, it is calculated by picking the shortest frameDuration from the segments. In other words, it picks the highest framerate from the segments. This is similar to the method used by <a href="https://developer.apple.com/documentation/avfoundation/avvideocomposition/1385892-videocompositionwithpropertiesof?language=objc">videoCompositionWithPropertiesOfAsset:</a>.
/// Will be <code>CMTime.positiveInfinity</code> if the video has no segments.
@property (nonatomic) CMTime frameDuration;
/// The playback speed of the video.
/// precondition:
/// Must be greater than zero.
/// note:
/// The speed of individual segments can be set with <code>SessionVideoSegment</code> <code>SessionVideoSegment.speedMultiplier</code> instead.
/// For example:
/// A value of <code>2</code> with result in 2x faster playback speed.
/// A value of <code>.5</code> will result .5x slower playback speed.
/// A value of <code>1</code> will result in normal playback speed.
/// Default value: <code>1</code>
@property (nonatomic) double speedMultiplier;
/// The URL location of the final video file (with all segments stiched together) after it has been exported. There will only be a file here after the export has been completed for the video. You may move, copy or delete this file. See <code>VideoExporter</code> for more information.
@property (nonatomic, readonly, copy) NSURL * _Nonnull exportedVideoURL;
/// The UTC date when the last successful video export started.
@property (nonatomic, readonly, copy) NSDate * _Nullable dateExported;
/// Indicates if the export was completed.
/// If the sessions dateModified is an older date than the videos dateExported, this will be false. In other words, if you export the video this will become true but if you then make modifications to the video this will flip back to false. The exportedVideoURL file must also exist for this to be true.
@property (nonatomic, readonly) BOOL isExported;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// For more information see <code>Session</code> documentation.
SWIFT_CLASS("_TtC8PixelSDK19SessionVideoSegment")
@interface SessionVideoSegment : NSObject
/// The pixel dimensions of the original video. Does not take into account the preferredTransform.
@property (nonatomic, readonly) CGSize naturalSize;
/// The pixel dimensions of the original video with the preferredTransform taken into account.
@property (nonatomic, readonly) CGSize actualSize;
/// The preferredTransform takes into account any rotation that should be made to the video segment.
/// If the video segment originally came with a preferredTransform, it will be set here.
/// 90° rotation increments made by the <code>EditController</code> will also be reflected here.
/// Default value: <code>.identity</code>
@property (nonatomic) CGAffineTransform preferredTransform;
/// This returns a suggested cropRect for the segment. The returned cropRect will always touch two opposite edges of the segment actualSize and will be centered inside. The cropRect width/height ratio will match the video renderSize width/height ratio.
- (CGRect)suggestedCropRect SWIFT_WARN_UNUSED_RESULT;
/// The start time of the video segment after it has been trimmed.
/// <code>.zero</code> corresponds with a start time at the beginning of the video segment.
/// Speed is not factored into this time.
/// precondition:
/// Cannot be greater than <code>duration</code> and cannot be negative.
/// Default value: <code>.zero</code>
@property (nonatomic) CMTime trimStartTime;
/// The duration of the video segment after it has been trimmed.
/// This is the duration of video to play after the <code>trimStartTime</code>.
/// Speed is not factored into this time.
/// precondition:
/// Cannot be greater than <code>duration</code> - <code>trimStartTime</code> and cannot be negative.
/// Default value: <code>duration</code>
@property (nonatomic) CMTime trimDuration;
/// The final duration of the video segment after it has been trimmed and speed multipliers divided in.
/// Default value: <code>SessionVideoSegment.trimDuration</code> \ <code>SessionVideoSegment.speedMultiplier</code> \ <code>SessionVideo</code> <code>SessionVideo.speedMultiplier</code>
@property (nonatomic, readonly) CMTime renderDuration;
/// The original duration of the video segment. Originates from the <a href="https://developer.apple.com/documentation/avfoundation/avassettrack/1388335-timerange">timeRange</a> of the original AVAsset.
@property (nonatomic, readonly) CMTime duration;
/// The framerate for the video segment. Originates from the <a href="https://developer.apple.com/documentation/avfoundation/avassettrack/1388608-minframeduration">minFrameDuration</a> of the original AVAsset.
/// For example, a frameDuration of 1/30th of a second <code>CMTime(value: 1, timescale: 30)</code> would be a 30fps video segment.
/// Will be <code>CMTime(value: 1, timescale: 30)</code> if the minFrameDuration of the AVAsset is not known or cannot be calculated.
@property (nonatomic) CMTime frameDuration;
/// The playback speed for the current segment.
/// precondition:
/// Must be greater than zero.
/// note:
/// The speed of the whole video can be set with <code>SessionVideo</code> <code>SessionVideo.speedMultiplier</code> instead.
/// For example:
/// A value of <code>2</code> with result in 2x faster playback speed.
/// A value of <code>.5</code> will result .5x slower playback speed.
/// A value of <code>1</code> will result in normal playback speed.
/// Default value: <code>1</code>
@property (nonatomic) double speedMultiplier;
/// If the video segment came from the users Photo Library and there was location information associated, this will be set.
/// See the <a href="https://developer.apple.com/documentation/corelocation/cllocation">documentation</a> for CLLocation.
/// Default value: <code>nil</code>
@property (nonatomic, strong) CLLocation * _Nullable location;
/// The URL location of the final video segment file after it has been exported. There will only be a file here after an export has been completed for the individual segment. You may move, copy or delete this file. See <code>VideoExporter</code> for more information.
@property (nonatomic, readonly, copy) NSURL * _Nonnull exportedVideoURL;
/// The UTC date when the last successful video segment export started.
@property (nonatomic, readonly, copy) NSDate * _Nullable dateExported;
/// Indicates if the export was completed for the individual segment.
/// If the sessions dateModified is an older date than the video segments dateExported, this will be false. In other words, if you export the video segment this will become true but if you then make modifications to the video segment this will flip back to false. The exportedVideoURL file must also exist for this to be true.
@property (nonatomic, readonly) BOOL isExported;
/// Clears the thumbnail cache.
- (void)invalidateThumbnails;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end














#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
#ifndef PIXELSDK_SWIFT_H
#define PIXELSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import AVFoundation;
@import CoreGraphics;
@import CoreMedia;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="PixelSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif




@protocol CameraControllerDelegate;
@class UIView;
@class AVCapturePhotoSettings;
@class NSCoder;
@class UITraitCollection;
@protocol UIViewControllerTransitionCoordinator;
@class NSString;
@class NSBundle;

/// The <code>CameraController</code> can take photos with low UI latency and Vine style video while also applying realtime filters.
/// Filters can be applied by swiping left or right in the camera view, or by pressing the filters button.
/// The filters can be changed with the <code>PixelSDK.primaryFilters</code> variable.
/// <em>Figure 1</em> Camera controller
/// <img src="https://www.cdn.pixelsdk.com/assets/img/screenshots/sdk/camera_1.jpg" alt="Screenshot" width="190" height="auto" style="border-style: solid; border-width: 1px; border-color: LightGrey;"/>
/// This controller is used inside the <code>ContainerController</code> and can be used on its own by initializing
/// the container controller with only one mode <code>.photo</code> or <code>.video</code>.
/// The camera can be restricted to produce only content of a specific aspect ratio. For example square content:
/// \code
/// container.cameraController.aspectRatio = CGSize(width: 1, height: 1)
///
/// \endcodeBy default, the camera controller pushes an <code>EditController</code> onto the navigation stack after a photo or video is taken. This can be disabled by setting <code>showsEditControllerWhenDone</code> to false. You will also need to implement the <code>CameraControllerDelegate</code> in order to respond the <code>CameraControllerDelegate.cameraController(_:didFinishWithSession:)</code> delegate method.
SWIFT_CLASS("_TtC8PixelSDK16CameraController")
@interface CameraController : UIViewController
/// Set this delegate in order to handle events that occur in this controller.
/// Default value: <code>nil</code>
@property (nonatomic, weak) id <CameraControllerDelegate> _Nullable delegate;
/// Set this to false if you do not want the <code>EditController</code> pushed onto the navigation stack
/// after the user takes a photo or presses the Done button after taking a video.
/// You can push your own controller or dismiss this controller in the <code>CameraControllerDelegate.cameraController(_:didFinishWithSession:)</code> delegate method.
/// Default value: <code>true</code>
@property (nonatomic) BOOL showsEditControllerWhenDone;
/// Set this to true if you want the flash enabled.
/// Default value: <code>false</code>
@property (nonatomic) BOOL flashActive;
/// Set this to true if you want the front facing camera enabled or to false if you want the back facing camera enabled.
/// Default value: <code>false</code>
@property (nonatomic) BOOL frontFacingCameraActive;
/// Set this to true if you want the brightness slider to be visible.
/// Default value: <code>false</code>
@property (nonatomic) BOOL brightnessAdjustmentActive;
/// When true, if the device is held horizontally with the screen face up, the mode pictured below will appear.
/// <img src="https://www.cdn.pixelsdk.com/assets/img/docs/face_up_mode.jpg" alt="Face up mode" title="Face up mode" width="250" height="auto"/>
/// Default value: <code>true</code>
@property (nonatomic) BOOL faceUpModeAvailable;
/// When true, the user may double tap anywhere inside the camera view to switch between the front and back facing camera.
/// Default value: <code>true</code>
@property (nonatomic) BOOL doubleTapForFrontFacingCamera;
/// Optionally provide a custom view for the photo camera button. Your view must determine its own size with intrinsic content size or constraints.
/// Default value: <code>nil</code>
@property (nonatomic, strong) UIView * _Nullable photoCameraButtonView;
/// Optionally provide a custom view for the video camera button. Your view must determine its own size with intrinsic content size or constraints.
/// Default value: <code>nil</code>
@property (nonatomic, strong) UIView * _Nullable videoCameraButtonView;
/// The <a href="https://developer.apple.com/documentation/avfoundation/avcapturesession/preset">session preset</a> for video capture.
/// Default value: <code>.high</code>
@property (nonatomic) AVCaptureSessionPreset _Nonnull videoPreset;
/// A closure that returns newly allocated <a href="https://developer.apple.com/documentation/avfoundation/avcapturephotosettings">photo settings</a> for photo capture.
/// If you wish to enable or disable flash, set the <code>flashActive</code> variable.
/// Default value:
/// \code
/// {
///     let photoSettings = AVCapturePhotoSettings()
///     photoSettings.isAutoStillImageStabilizationEnabled = true
///     photoSettings.isHighResolutionPhotoEnabled = true
///     return photoSettings
/// }
///
/// \endcode
@property (nonatomic, copy) AVCapturePhotoSettings * _Nonnull (^ _Nonnull photoSettings)(void);
/// Use <code>aspectRatio</code> instead to enable square camera.
/// Default value: <code>false</code>
@property (nonatomic) BOOL squareCameraActive SWIFT_DEPRECATED_MSG("Only set aspectRatio now. This variable is no longer needed.");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// :nodoc:
- (void)viewDidLoad;
/// :nodoc:
- (void)viewWillAppear:(BOOL)animated;
/// :nodoc:
- (void)viewDidAppear:(BOOL)animated;
/// :nodoc:
- (void)viewWillDisappear:(BOOL)animated;
/// :nodoc:
- (void)viewDidDisappear:(BOOL)animated;
/// :nodoc:
- (void)viewWillLayoutSubviews;
/// :nodoc:
- (void)willTransitionToTraitCollection:(UITraitCollection * _Nonnull)newCollection withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
@property (nonatomic, readonly) UIStatusBarStyle preferredStatusBarStyle;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end




@interface CameraController (SWIFT_EXTENSION(PixelSDK))
@property (nonatomic, readonly) BOOL prefersBottomBarTransparent;
@end




@interface CameraController (SWIFT_EXTENSION(PixelSDK))
- (void)setNeedsBottomBarAppearanceUpdate;
@property (nonatomic, readonly, strong) UIView * _Nullable preferredBottomBarView;
@property (nonatomic, readonly) BOOL prefersBottomBarHidden;
@end





@class Session;
@class EditController;

/// Use this delegate to handle events that occur in the <code>CameraController</code>.
SWIFT_PROTOCOL("_TtP8PixelSDK24CameraControllerDelegate_")
@protocol CameraControllerDelegate
@optional
/// This will be called when the Cross button is pressed.
/// \param cameraController The controller responsible for calling this method.
///
- (void)cameraControllerDidCancel:(CameraController * _Nonnull)cameraController;
/// This will be called when a photo is taken or the Done button is pressed while taking video.
/// \param cameraController The controller responsible for calling this method.
///
/// \param session The session that was generated by the <code>CameraController</code>.
/// If <code>showsEditControllerWhenDone</code> is false, you are responsible for destroying the session if you do not want it to persist.
/// If it is true, destroying the session will result in undocumented behavior.
///
- (void)cameraController:(CameraController * _Nonnull)cameraController didFinishWithSession:(Session * _Nonnull)session;
/// This will be called when a photo is taken or the Done button is pressed while taking video, and <code>showsEditControllerWhenDone</code> is true.
/// If you wish to make any additional customizations to the ‘EditController’ before it is pushed, you may do so here.
/// \param cameraController The controller responsible for calling this method.
///
/// \param editController The new <code>EditController</code> that will be pushed onto the navigation stack.
///
/// \param session The session that was generated by the <code>CameraController</code> and will be
/// passed to the <code>EditController</code>. Destroying the session will result in undocumented behavior.
///
- (void)cameraController:(CameraController * _Nonnull)cameraController willShowEditController:(EditController * _Nonnull)editController withSession:(Session * _Nonnull)session;
/// This is called when the user began pressing the photo camera button to initiate capture.
/// You can implement this method to produce a custom shutter sound or haptic feedback.
/// \param cameraController The controller responsible for calling this method.
///
- (void)cameraControllerPhotoCameraButtonTouchesBegan:(CameraController * _Nonnull)cameraController;
/// This is called when the user finished pressing the photo camera button to initiate capture.
/// You can implement this method to produce a custom shutter sound or haptic feedback.
/// \param cameraController The controller responsible for calling this method.
///
- (void)cameraControllerPhotoCameraButtonTouchesEnded:(CameraController * _Nonnull)cameraController;
/// This is called when the user finished pressing the photo camera button to initiate capture but the touch was ignored.
/// \param cameraController The controller responsible for calling this method.
///
- (void)cameraControllerPhotoCameraButtonTouchesCancelled:(CameraController * _Nonnull)cameraController;
/// This is called when the user began pressing the video camera button to initiate capture.
/// You can implement this method to produce a custom shutter sound or haptic feedback.
/// \param cameraController The controller responsible for calling this method.
///
- (void)cameraControllerVideoCameraButtonTouchesBegan:(CameraController * _Nonnull)cameraController;
/// This is called when the user finished pressing the video camera button to finish capture.
/// You can implement this method to produce a custom shutter sound or haptic feedback.
/// \param cameraController The controller responsible for calling this method.
///
- (void)cameraControllerVideoCameraButtonTouchesEnded:(CameraController * _Nonnull)cameraController;
/// This is called when the user finished pressing the video camera button to finish capture but the touch was ignored.
/// \param cameraController The controller responsible for calling this method.
///
- (void)cameraControllerVideoCameraButtonTouchesCancelled:(CameraController * _Nonnull)cameraController;
@end

@protocol ContainerControllerDelegate;
@protocol EditControllerDelegate;
@class LibraryController;

/// The <code>ContainerController</code> view consists of a tab bar at the bottom and a controller above it.
/// Each tab is represented by a <code>ContainerMode</code> with an associated controller and title for the tab.
/// The tab bar can be customized by initializing this controller with the modes of your choosing.
/// If you initialize a <code>ContainerController</code> with only one mode, the tab bar will be automatically hidden.
SWIFT_CLASS("_TtC8PixelSDK19ContainerController")
@interface ContainerController : UIViewController
/// Creates a <code>ContainerController</code> with the modes <code>[.library, .photo, .video]</code>
/// and an initialMode of <code>.photo</code>. For additional information see <code>init(modes:initialMode:restoresPreviousMode:)</code>.
- (nonnull instancetype)init;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// Set this delegate in order to handle events that occur in this controller or any of its children controllers.
/// Default value: <code>nil</code>
@property (nonatomic, weak) id <ContainerControllerDelegate> _Nullable delegate;
/// Whenever the <code>LibraryController</code> or <code>CameraController</code> pushes a new <code>EditController</code> onto the navigation stack
/// it will always set its delegate to whatever the value of this variable is.
/// You should set this so you can respond to user interaction in the <code>EditController</code>.
/// Default value: <code>nil</code>
@property (nonatomic, weak) id <EditControllerDelegate> _Nullable editControllerDelegate;
/// The instance of the <code>CameraController</code> that will be displayed for either the .photo or .video modes.
@property (nonatomic, readonly, strong) CameraController * _Nonnull cameraController;
/// The instance of the <code>LibraryController</code> that will be displayed for the .library mode.
@property (nonatomic, readonly, strong) LibraryController * _Nonnull libraryController;
/// :nodoc:
- (void)viewDidLoad;
/// :nodoc:
- (void)viewWillAppear:(BOOL)animated;
/// :nodoc:
- (void)viewWillDisappear:(BOOL)animated;
/// :nodoc:
- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
- (void)willTransitionToTraitCollection:(UITraitCollection * _Nonnull)newCollection withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
@property (nonatomic, readonly) UIInterfaceOrientationMask supportedInterfaceOrientations;
/// :nodoc:
@property (nonatomic, readonly, strong) UIViewController * _Nullable childViewControllerForStatusBarStyle;
/// :nodoc:
@property (nonatomic, readonly) BOOL prefersStatusBarHidden;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end



@interface ContainerController (SWIFT_EXTENSION(PixelSDK))
@property (nonatomic, readonly) BOOL prefersBottomBarHidden;
@property (nonatomic, readonly, strong) UIView * _Nullable preferredBottomBarView;
- (void)setNeedsBottomBarAppearanceUpdate;
@end


/// Use this delegate to handle events that occur in the <code>ContainerController</code> or any of its children controllers.
SWIFT_PROTOCOL("_TtP8PixelSDK27ContainerControllerDelegate_")
@protocol ContainerControllerDelegate
@optional
/// This will be called whenever the user switches between tabs.
/// You can retrieve the new mode from the <code>ContainerController.currentMode</code> variable.
/// \param containerController The controller responsible for calling this method.
///
- (void)containerControllerDidChangeMode:(ContainerController * _Nonnull)containerController;
/// This will be called when either the Cancel button is pressed in the <code>LibraryController</code> or the cross
/// button is pressed in the <code>CameraController</code>.
/// \param containerController The controller responsible for calling this method.
///
- (void)containerControllerDidCancel:(ContainerController * _Nonnull)containerController;
/// This will be called when either the <code>LibraryController</code> or <code>CameraController</code> is about to push a
/// new <code>EditController</code> onto the navigation stack. If you wish to make any additional customizations to the <code>EditController</code>
/// before it is pushed, you may do so here.
/// \param containerController The controller responsible for calling this method.
///
/// \param editController The new <code>EditController</code> that will be pushed onto the navigation stack.
///
/// \param session The session that was generated by the <code>LibraryController</code> or <code>CameraController</code> and will be
/// passed to the <code>EditController</code>. Destroying the session will result in undocumented behavior.
///
- (void)containerController:(ContainerController * _Nonnull)containerController willShowEditController:(EditController * _Nonnull)editController withSession:(Session * _Nonnull)session;
@end

///
typedef SWIFT_ENUM(NSInteger, ContentMode, open) {
/// Media scaled to fill the space. Distortion may occur.
  ContentModeContentFill = 0,
/// Media scaled to fit the space while maintaining the media’s original aspect ratio.
  ContentModeContentAspectFit = 1,
/// Media scaled to fill the space while maintaining the media’s original aspect ratio. A portion of the media may be clipped or spill out of the space.
  ContentModeContentAspectFill = 2,
};


@class UIButton;

/// The primary functionality of the <code>EditController</code> includes filter selection, filter intensity, adjustments (brightness, vibrance, saturation, etc.), cropping, rotation, horizontal/vertical perspective correction, and video segment composing/trimming/re-ordering.
/// The edit controller is always presented with an image or video based <code>Session</code> object. Sessions can be edited programmatically by changing filters, crop rects, trim times and more. The edit controller will display all programmatic changes to a session in its interface. For more information on modifying a session see the <code>Session</code> documentation.
/// When presented with an image based session, the controller consists of two tabs Filter and Adjust. When presented with a video, the controller consists of three tabs Filter, Trim and Adjust. You may edit media of any aspect ratio. All editing functionality available to images is also available to videos.
/// Normally the edit controller is pushed onto the navigation stack by either the <code>LibraryController</code> or <code>CameraController</code>. You may also present the edit controller manually with a <code>Session</code> for example:
/// \code
/// let image = UIImage(named: "test_image")!
///
/// let session = Session(image: image)
///
/// let editController = EditController(session: session)
/// editController.delegate = self
///
/// let nav = UINavigationController(rootViewController: editController)
/// nav.modalPresentationStyle = .fullScreen
/// self.present(nav, animated: true, completion: nil)
///
/// \endcodeattention:
/// Sessions are automatically saved so you a responsible for calling <code>Session.destroy()</code> when you are done with a session (unless noted otherwise). If you do not destroy a session it will persist in the users Drafts in memory and on disk.
/// You may also present an edit controller with one or more AVAssets, for example:
/// \code
/// let asset1 = AVAsset(url: Bundle.main.url(forResource: "test", withExtension: "mov")!)
/// let asset2 = AVAsset(url: Bundle.main.url(forResource: "test2", withExtension: "mp4")!)
///
/// let _ = Session(assets: [asset1, asset2], sessionReady: { (session, error) in
///     guard let session = session else {
///         print("Unable to create session: \(error!)")
///         return
///     }
///
///     let editController = EditController(session: session)
///     editController.delegate = self
///
///     let nav = UINavigationController(rootViewController: editController)
///     nav.modalPresentationStyle = .fullScreen
///     self.present(nav, animated: true, completion: nil)
/// })
///
/// \endcodeFilters under the Filter or Adjust tabs may be changed by setting the <code>PixelSDK.primaryFilters</code> <code>PixelSDK.adjustmentFilters</code> variables respectively.
/// The Adjust tab places the Position (cropping) button before the adjust filters. Cropping can be disabled by setting <code>showsPositionAdjustment</code> to false.
SWIFT_CLASS("_TtC8PixelSDK14EditController")
@interface EditController : UIViewController
/// Creates an <code>EditController</code> with the provided session. The session you pass here will be automatically saved when any changes are made by the controller.
/// warning:
/// Modifying the session after the controller has been presented may result in undocumented behavior.
/// precondition:
/// Provided session must not be destroyed.
/// \param session The session to initialize the <code>EditController</code> with.
///
- (nonnull instancetype)initWithSession:(Session * _Nonnull)session OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// The session the <code>EditController</code> was initialized with.
@property (nonatomic, readonly, strong) Session * _Nonnull session;
/// Set this delegate in order to handle events that occur in this controller.
/// Default value: <code>nil</code>
@property (nonatomic, weak) id <EditControllerDelegate> _Nullable delegate;
/// The back button in the top left corner of this controller.
@property (nonatomic, readonly, strong) IBOutlet UIButton * _Null_unspecified backButton;
/// The Next button in the top right corner of this controller.
@property (nonatomic, readonly, strong) IBOutlet UIButton * _Null_unspecified nextButton;
/// When “Keep Draft” is pressed in the save dialogue, no action is taken since the session has already been automatically saved.
/// When “Discard” is pressed in the save dialogue, the session is destroyed by calling <code>Session.destroy()</code>.
/// If this is true, the controller may show the save dialogue when the back button is pressed.
/// <code>Session.isTransient</code> must be false and there must have been changes to the session for a save dialogue to appear.
/// If this is false, no save dialogue will be shown when the back button button is pressed.
/// For all cases where no save dialogue appears, the session will stay saved and <code>Session.destroy()</code> will not be called.
/// Default value: <code>true</code>
@property (nonatomic) BOOL showsSaveDialogue;
/// If you would like to disable cropping, rotation and horizontal/vertical perspective correction set this to false.
/// This will hide the Position button found in the Adjust tab.
/// Default value: <code>true</code>
@property (nonatomic) BOOL showsPositionAdjustment;
/// Set this to true if you want to reduce the height of the editor controls and increase the height of the media preview. This can improve the user experience if portrait content is edited frequently.
/// If this controller is presented by a <code>LibraryController</code> or <code>CameraController</code> with a portrait aspect ratio, the default value may be <code>true</code> instead of <code>false</code>.
/// Default value: <code>false</code>
@property (nonatomic) BOOL compactControls;
/// :nodoc:
- (void)viewDidLoad;
/// :nodoc:
- (void)viewDidLayoutSubviews;
/// :nodoc:
- (void)viewWillAppear:(BOOL)animated;
/// :nodoc:
- (void)viewDidAppear:(BOOL)animated;
/// :nodoc:
- (void)viewWillDisappear:(BOOL)animated;
/// :nodoc:
- (void)viewDidDisappear:(BOOL)animated;
/// :nodoc:
- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
- (void)willTransitionToTraitCollection:(UITraitCollection * _Nonnull)newCollection withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
@property (nonatomic, readonly) UIInterfaceOrientationMask supportedInterfaceOrientations;
/// :nodoc:
@property (nonatomic, readonly) BOOL prefersStatusBarHidden;
/// :nodoc:
@property (nonatomic, readonly) UIStatusBarStyle preferredStatusBarStyle;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end



@interface EditController (SWIFT_EXTENSION(PixelSDK))
/// :nodoc:
@property (nonatomic, readonly, strong) UIView * _Nullable preferredTopBarView;
/// :nodoc:
- (void)setNeedsTopBarAppearanceUpdate;
@end





@interface EditController (SWIFT_EXTENSION(PixelSDK))
@property (nonatomic, readonly) BOOL prefersBottomBarHidden;
@property (nonatomic, readonly, strong) UIView * _Nullable preferredBottomBarView;
- (void)setNeedsBottomBarAppearanceUpdate;
@end



/// Use this delegate to handle events that occur in the <code>EditController</code>.
SWIFT_PROTOCOL("_TtP8PixelSDK22EditControllerDelegate_")
@protocol EditControllerDelegate
@optional
/// This will be called after <code>EditController</code> viewDidLoad. This will only be called once per <code>EditController</code>.
/// \param editController The controller responsible for calling this method.
///
/// \param session The session the editController will be editing.
///
- (void)editController:(EditController * _Nonnull)editController didLoadEditing:(Session * _Nonnull)session;
/// This will be called at the end of <code>EditController</code> viewWillAppear.
/// \param editController The controller responsible for calling this method.
///
/// \param session The session the editController will be editing.
///
- (void)editController:(EditController * _Nonnull)editController willBeginEditing:(Session * _Nonnull)session;
/// This will be called at the end of <code>EditController</code> viewDidAppear.
/// \param editController The controller responsible for calling this method.
///
/// \param session The session the editController will be editing.
///
- (void)editController:(EditController * _Nonnull)editController didBeginEditing:(Session * _Nonnull)session;
@required
/// This will be called when the Next button is pressed. You should push on a new controller to the navigation stack or dismiss the controller here.
/// attention:
/// You are responsible for destroying the provided session if you do not want it to persist.
/// \param editController The controller responsible for calling this method.
///
/// \param session The session the controller has finished editing.
///
- (void)editController:(EditController * _Nonnull)editController didFinishEditing:(Session * _Nonnull)session;
@optional
/// This will be called when the back button is pressed. If a save dialogue gets presented, this will be called after the dialogue has been dismissed.
/// \param editController The controller responsible for calling this method.
///
/// \param session The session the controller has cancelled editing. If the session was not destroyed by the <code>EditController</code> it will be passed here. To understand when a session will be destroyed see <code>EditController.showsSaveDialogue</code> for more information. If the <code>EditController</code> was shown by a <code>CameraController</code> and you destroy the session it will lead to undocumented behavior since the camera depends on the session.
///
- (void)editController:(EditController * _Nonnull)editController didCancelEditing:(Session * _Nullable)session;
@end

@protocol LibraryControllerDelegate;
@class NSPredicate;
@class UIActivityIndicatorView;
@class PreviewCropController;

/// The <code>LibraryController</code> offers a way to quickly select and crop images or videos from the users Photo Library. Users can switch between regular albums, smart albums, iCloud albums, or albums imported directly from a DSLR camera. In addition, there is a separate section for selecting and deleting drafts.
/// <em>Figure 1</em> Library controller
/// <img src="https://www.cdn.pixelsdk.com/assets/img/screenshots/sdk/library_1.jpg" alt="Screenshot" width="190" height="auto" style="border-style: solid; border-width: 1px; border-color: LightGrey;"/>
/// This controller is used inside the <code>ContainerController</code> and can be used on its own by initializing
/// the container controller with only one mode <code>.library</code>.
/// For more information on modifying the cropping behavior of the library controller see its <code>PreviewCropController</code>.
/// The library controller can also be restricted to only display certain types of media. For example images only:
/// \code
/// containerController.libraryController.fetchPredicate = NSPredicate(format: "mediaType == %d", PHAssetMediaType.image.rawValue)
/// containerController.libraryController.draftMediaTypes = [.image]
///
/// \endcodeBy default, the library controller pushes an <code>EditController</code> onto the navigation stack when the Next button is pressed. This can be disabled by setting <code>showsEditControllerWhenDone</code> to false. You will also need to implement the <code>LibraryControllerDelegate</code> in order to respond the <code>LibraryControllerDelegate.libraryController(_:didFinishWithSession:withSegment:)</code> delegate method.
SWIFT_CLASS("_TtC8PixelSDK17LibraryController")
@interface LibraryController : UIViewController
/// Set this delegate in order to handle events that occur in this controller.
/// Default value: <code>nil</code>
@property (nonatomic, weak) id <LibraryControllerDelegate> _Nullable delegate;
/// Set this to false if you do not want the <code>EditController</code> pushed onto the navigation stack
/// after the user presses the Next button.
/// You can push your own controller or dismiss this controller in the <code>LibraryControllerDelegate.libraryController(_:didFinishWithSession:withSegment:)</code> delegate method.
/// Default value: <code>true</code>
@property (nonatomic) BOOL showsEditControllerWhenDone;
/// Set this if you need to restrict the users Photo Library to a certain type of media.
/// Only images for example:
/// \code
/// libraryController.fetchPredicate = NSPredicate(format: "mediaType == %d", PHAssetMediaType.image.rawValue)
///
/// \endcodeDefault value: <code>nil</code>
@property (nonatomic, strong) NSPredicate * _Nullable fetchPredicate;
/// When false, each video draft will appear as one draft.
/// When true, each video draft will be displayed as individual segments. For example, if a video has 3 segments the draft will instead appear as 3 separate drafts.
/// Default value: <code>false</code>
@property (nonatomic) BOOL splitVideoDraftsIntoSegments;
/// The Cancel button in the top left corner of this controller.
@property (nonatomic, readonly, strong) IBOutlet UIButton * _Null_unspecified cancelButton;
/// The Next button in the top right corner of this controller.
@property (nonatomic, readonly, strong) IBOutlet UIButton * _Null_unspecified nextButton;
/// This activity indicator may briefly appear in place of the <code>nextButton</code> after it is pressed.
@property (nonatomic, readonly, strong) IBOutlet UIActivityIndicatorView * _Null_unspecified activityIndicatorView;
/// This is the square preview controller at the top of this controller responsible for displaying and cropping media.
/// Use this to customize cropping behavior.
@property (nonatomic, readonly, strong) PreviewCropController * _Nonnull previewCropController;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// :nodoc:
- (void)viewDidLoad;
/// :nodoc:
- (void)viewWillLayoutSubviews;
/// :nodoc:
- (void)viewWillAppear:(BOOL)animated;
/// :nodoc:
- (void)viewDidAppear:(BOOL)animated;
/// :nodoc:
- (void)viewWillDisappear:(BOOL)animated;
/// :nodoc:
- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
- (void)willTransitionToTraitCollection:(UITraitCollection * _Nonnull)newCollection withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
@property (nonatomic, readonly) UIStatusBarStyle preferredStatusBarStyle;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end


@class UIGestureRecognizer;

@interface LibraryController (SWIFT_EXTENSION(PixelSDK)) <UIGestureRecognizerDelegate>
- (BOOL)gestureRecognizer:(UIGestureRecognizer * _Nonnull)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer * _Nonnull)otherGestureRecognizer SWIFT_WARN_UNUSED_RESULT;
@end



@interface LibraryController (SWIFT_EXTENSION(PixelSDK))
@property (nonatomic, readonly) BOOL prefersBottomBarHidden;
@end







@class SessionVideoSegment;

/// Use this delegate to handle events that occur in the <code>LibraryController</code>.
SWIFT_PROTOCOL("_TtP8PixelSDK25LibraryControllerDelegate_")
@protocol LibraryControllerDelegate
@optional
/// This will be called when the Cancel button is pressed.
/// \param libraryController The controller responsible for calling this method.
///
- (void)libraryControllerDidCancel:(LibraryController * _Nonnull)libraryController;
/// This will be called when the Next button is pressed.
/// \param libraryController The controller responsible for calling this method.
///
/// \param session The session that was generated by the <code>LibraryController</code>.
/// If <code>showsEditControllerWhenDone</code> is false, you are responsible for destroying the session if you do not want it to persist.
/// If it is true, destroying the session will result in undocumented behavior.
///
/// \param segment This will be passed if the user selected a specific segment from the session.
/// This will only happen if <code>splitVideoDraftsIntoSegments</code> is true.
///
- (void)libraryController:(LibraryController * _Nonnull)libraryController didFinishWithSession:(Session * _Nonnull)session withSegment:(SessionVideoSegment * _Nullable)segment;
/// This will be called when the Next button is pressed and <code>showsEditControllerWhenDone</code> is true.
/// If you wish to make any additional customizations to the ‘EditController’ before it is pushed, you may do so here.
/// \param libraryController The controller responsible for calling this method.
///
/// \param editController The new <code>EditController</code> that will be pushed onto the navigation stack.
///
/// \param session The session that was generated by the <code>LibraryController</code> and will be
/// passed to the <code>EditController</code>. Destroying the session will result in undocumented behavior.
///
- (void)libraryController:(LibraryController * _Nonnull)libraryController willShowEditController:(EditController * _Nonnull)editController withSession:(Session * _Nonnull)session;
@end




@protocol PreviewControllerDelegate;

/// Preview controllers let you draw any image or video based <code>Session</code> object.
/// For example, you can use the <code>PreviewController</code> class to display the contents of a session found in the <code>SessionManager.savedSessions</code> array (user Drafts) or even a <code>Session</code> you have just initialized. You configure a preview controller programmatically by adding its view as a subview to the view of your choosing. For video, you can also use methods of this class to start or stop the video and specify other playback parameters.
/// The preview controller will also display <a href="https://www.pixelsdk.com/docs/latest/Classes/Session.html#modifying-sessions">programmatic edits</a> that are made on a session in real-time.
/// <em>Figure 1</em> Preview controller
/// <img src="https://www.cdn.pixelsdk.com/assets/img/docs/filter_original.jpg" alt="Preview controller" title="Preview controller" width="250" height="auto"/>
/// A preview controller uses the <code>contentMode</code> variable and the size of the media itself to determine how to display the media. The preview controller can scale your media to fit all or some of the available space. If the size of the preview controller changes, it automatically scales the media as needed.
/// The presentation of the media is determined by the preview controllers <code>contentMode</code> property. The <code>ContentMode.contentAspectFit</code> and <code>ContentMode.contentAspectFill</code> values scale the media to fit or fill the space while maintaining the media’s original aspect ratio. The <code>ContentMode.contentFill</code> value scales the media without regard to the original aspect ratio, which can cause the media to appear distorted.
/// The below example creates a preview controller, adds it as a child of your controller and as a subview of your view.
/// It then anchors the preview controller 30 points from the left of your view and 100 points from the top of your view.
/// The preview controller is also given a height of 200 points and a width of 200 points.
/// \code
/// override func viewDidLoad() {
///     super.viewDidLoad()
///
///     let controller = PreviewController()
///     self.addChild(controller)
///     self.view.addSubview(controller.view)
///
///     controller.view.translatesAutoresizingMaskIntoConstraints = false
///     controller.view.leftAnchor.constraint(equalTo: self.view.leftAnchor, constant: 30).isActive = true
///     controller.view.topAnchor.constraint(equalTo: self.view.topAnchor, constant: 100).isActive = true
///     controller.view.heightAnchor.constraint(equalToConstant: 200).isActive = true
///     controller.view.widthAnchor.constraint(equalToConstant: 200).isActive = true
///
///     controller.session = <#Your Session#>
/// }
///
/// \endcode
SWIFT_CLASS("_TtC8PixelSDK17PreviewController")
@interface PreviewController : UIViewController
/// Creates a <code>PreviewController</code>.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// Set this delegate if you want to make changes to the preview controller view layout
/// using the size of the media before or after it has appeared.
/// Default value: <code>nil</code>
@property (nonatomic, weak) id <PreviewControllerDelegate> _Nullable delegate;
/// :nodoc:
- (void)viewDidLoad;
/// :nodoc:
- (void)viewWillDisappear:(BOOL)animated;
/// :nodoc:
- (void)viewDidDisappear:(BOOL)animated;
/// :nodoc:
- (void)viewWillAppear:(BOOL)animated;
/// :nodoc:
- (void)viewDidAppear:(BOOL)animated;
/// :nodoc:
- (void)didReceiveMemoryWarning;
/// The session to be displayed by the preview controller.
/// All changes made to the session (changing filters, trim times, preferredTransform, etc.) will be automatically displayed by the preview controller in real-time.
/// Default value: <code>nil</code>
@property (nonatomic, strong) Session * _Nullable session;
/// The preview controller uses the <code>contentMode</code> variable and the size of the media itself to determine how to display the media. The preview controller can scale your media to fit all or some of the available space.
/// The <code>ContentMode.contentAspectFit</code> and <code>ContentMode.contentAspectFill</code> values scale the media to fit or fill the space while maintaining the media’s original aspect ratio.
/// The <code>ContentMode.contentFill</code> value scales the media without regard to the original aspect ratio, which can cause the media to appear distorted.
/// Default value: <code>.contentAspectFit</code>
@property (nonatomic) enum ContentMode contentMode;
/// Controls whether or not the video should loop.
/// Default value: <code>true</code>
@property (nonatomic) BOOL loops;
/// Controls whether or not the video is muted.
/// Key value observable.
/// Default value: <code>false</code>
@property (nonatomic) BOOL isMuted;
/// The current time of the video playback.
/// Default value: <code>.zero</code>
@property (nonatomic, readonly) CMTime currentTime;
/// When true, the video will automatically start playing after the <code>session</code> variable is set.
/// Default value: <code>true</code>
@property (nonatomic) BOOL autoplayEnabled;
/// Indicates if the video is currently playing. The video may still be loading when this is true.
/// Default value: <code>false</code>
@property (nonatomic, readonly) BOOL isPlaying;
/// Begins playback of the video.
/// Immediately after this is called, <code>isPlaying</code> will be true.
- (void)play;
/// Pauses playback of the video.
/// Immediately after this is called, <code>isPlaying</code> will be false.
- (void)pause;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end



/// Set this delegate if you want to make changes to the <code>PreviewController</code> view layout
/// using the size of the media before or after it has appeared.
SWIFT_PROTOCOL("_TtP8PixelSDK25PreviewControllerDelegate_")
@protocol PreviewControllerDelegate
/// Called before the <code>PreviewController</code> has displayed the media. Use this time to handle any additional layout for the view.
/// \param previewController The controller responsible for calling this method.
///
/// \param size The actual size of the media. This is not the size in points of the media on the screen.
///
- (void)previewControllerWillDisplayMedia:(PreviewController * _Nonnull)previewController withSize:(CGSize)size;
/// Called after the <code>PreviewController</code> has displayed the media.
/// \param previewController The controller responsible for calling this method.
///
/// \param size The actual size of the media. This is not the size in points of the media on the screen.
///
- (void)previewControllerDidDisplayMedia:(PreviewController * _Nonnull)previewController withSize:(CGSize)size;
@end

@class UITouch;
@class UIEvent;

/// The <code>PreviewCropController</code> handles cropping for media in the <code>LibraryController</code>.
/// <em>Figure 1</em> Preview crop controller
/// <img src="https://www.cdn.pixelsdk.com/assets/img/docs/crop_controller.jpg" alt="Preview crop controller" title="Preview crop controller" width="250" height="auto"/>
/// The crop controller can be accessed with the following:
/// \code
/// let cropController = containerController.libraryController.previewCropController
///
/// \endcodeThe below examples demonstrate a few custom variations in cropping behavior.
/// Allow only content of a specific aspect ratio. For example square content only:
/// \code
/// cropController.aspectRatio = CGSize(width: 1, height: 1)
///
/// \endcodeAllow only content of a maximum aspect ratio. This is the default functionality.
/// \code
/// cropController.maxRatioForPortraitMedia = CGSize(width: 3, height: 4)
/// cropController.maxRatioForLandscapeMedia = CGSize(width: 16, height: 9)
///
/// \endcodeSet content initially zoomed in or out. For example initially zoomed out:
/// \code
/// cropController.defaultsToAspectFillForPortraitMedia = false
/// cropController.defaultsToAspectFillForLandscapeMedia = false
///
/// \endcodeApply no initial cropping, unless the user interacts with the cropper:
/// \code
/// cropController.maxRatioForPortraitMedia = CGSize(width: 1, height: .max)
/// cropController.maxRatioForLandscapeMedia = CGSize(width: .max, height: 1)
///
/// cropController.defaultsToAspectFillForPortraitMedia = false
/// cropController.defaultsToAspectFillForLandscapeMedia = false
///
/// \endcodeDisable cropping from user interaction:
/// \code
/// cropController.userInteractionEnabled = false
///
/// \endcodeIf the last two examples are combined, cropping will be disabled entirely.
SWIFT_CLASS("_TtC8PixelSDK21PreviewCropController")
@interface PreviewCropController : UIViewController
/// If this is true when portrait media is loaded into the crop controller, the media will by default be zoomed in to fill the crop controller and if false it will by default be zoomed out.
/// Setting this to true will bias the user to produce square content and false will bias them to produce portrait content.
/// If media has already loaded in, you must call <code>layoutMedia()</code> after setting this for an immediate effect.
/// attention:
/// This variable has no effect if <code>aspectRatio</code> is set.
/// Default value: <code>true</code>
@property (nonatomic) BOOL defaultsToAspectFillForPortraitMedia;
/// If this is true when landscape media is loaded into the crop controller, the media will by default be zoomed in to fill the crop controller and if false it will by default be zoomed out.
/// Setting this to true will bias the user to produce square content and false will bias them to produce landscape content.
/// If media has already loaded in, you must call <code>layoutMedia()</code> after setting this for an immediate effect.
/// attention:
/// This variable has no effect if <code>aspectRatio</code> is set.
/// Default value: <code>true</code>
@property (nonatomic) BOOL defaultsToAspectFillForLandscapeMedia;
/// Call this function if you want to briefly flash the grid lines.
- (void)flashGridLines;
/// This ratio is the maximum amount of content that can be visible when portrait media is zoomed all the way out.
/// If media has already loaded in, you must call <code>layoutMedia()</code> after setting this for an immediate effect.
/// attention:
/// This variable has no effect if <code>aspectRatio</code> is set.
/// precondition:
/// Size width must be less than size height.
/// Default value: <code>CGSize(width: 3, height: 4)</code>
@property (nonatomic) CGSize maxRatioForPortraitMedia;
/// This ratio is the maximum amount of content that can be visible when landscape media is zoomed all the way out.
/// If media has already loaded in, you must call <code>layoutMedia()</code> after setting this for an immediate effect.
/// attention:
/// This variable has no effect if <code>aspectRatio</code> is set.
/// precondition:
/// Size width must be greater than size height.
/// Default value: <code>CGSize(width: 16, height: 9)</code>
@property (nonatomic) CGSize maxRatioForLandscapeMedia;
/// Controls whether cropping is enabled.
/// Default: <code>true</code>
@property (nonatomic) BOOL userInteractionEnabled;
/// Controls whether video media should be paused when the user is dragging it in the crop controller.
/// Default value: <code>true</code>
@property (nonatomic) BOOL pausesVideoOnDrag;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// :nodoc:
- (void)viewDidLoad;
/// :nodoc:
- (void)viewWillAppear:(BOOL)animated;
/// :nodoc:
- (void)viewWillLayoutSubviews;
/// :nodoc:
- (void)viewDidLayoutSubviews;
/// :nodoc:
- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
/// :nodoc:
- (void)touchesBegan:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
/// :nodoc:
- (void)touchesEnded:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
/// :nodoc:
- (void)touchesCancelled:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
/// This will layout the media again and reset its position.
- (void)layoutMedia;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end


@interface PreviewCropController (SWIFT_EXTENSION(PixelSDK)) <PreviewControllerDelegate>
- (void)previewControllerWillDisplayMedia:(PreviewController * _Nonnull)previewController withSize:(CGSize)size;
- (void)previewControllerDidDisplayMedia:(PreviewController * _Nonnull)previewController withSize:(CGSize)size;
@end

@class UIScrollView;

@interface PreviewCropController (SWIFT_EXTENSION(PixelSDK)) <UIScrollViewDelegate>
- (UIView * _Nullable)viewForZoomingInScrollView:(UIScrollView * _Nonnull)scrollView SWIFT_WARN_UNUSED_RESULT;
- (void)scrollViewDidScroll:(UIScrollView * _Nonnull)scrollView;
- (void)scrollViewWillBeginDragging:(UIScrollView * _Nonnull)scrollView;
- (void)scrollViewDidEndDragging:(UIScrollView * _Nonnull)scrollView willDecelerate:(BOOL)decelerate;
- (void)scrollViewDidEndDecelerating:(UIScrollView * _Nonnull)scrollView;
- (void)scrollViewDidZoom:(UIScrollView * _Nonnull)scrollView;
- (void)scrollViewWillBeginZooming:(UIScrollView * _Nonnull)scrollView withView:(UIView * _Nullable)view;
- (void)scrollViewDidEndZooming:(UIScrollView * _Nonnull)scrollView withView:(UIView * _Nullable)view atScale:(CGFloat)scale;
@end

@class UIImage;
@class SessionImage;
@class SessionVideo;
@class NSDate;

/// <h3>Overview</h3>
/// A <code>Session</code> is analogous to a project in photo and video editing software. A session can contain either a <code>SessionImage</code> or <code>SessionVideo</code> composed of one or more <code>SessionVideoSegment</code> objects. Sessions are mutable and store all information related to the rendering of their media including files, crop rects, filters, trim times, etc. They also contain metadata like modification time, userInfo, and latitude/longitude.
/// You can use session objects in several different ways:
/// <ul>
///   <li>
///     Assign a session to a <code>PreviewController</code> object to display the session in your interface.
///   </li>
///   <li>
///     Initialize an <code>EditController</code> with a session so you can make edits visually.
///   </li>
///   <li>
///     Programmatically make real-time modifications to a session like set filters, crop rects, segment trim times, etc.
///   </li>
/// </ul>
/// <h3>Creating Session Objects</h3>
/// When creating session objects using the methods of this class, you must have an existing image or video located in a file, UIImage, or local AVAsset. You cannot create an empty session and later add media. There are a couple options for creating session objects, each of which is best for specific situations:
/// <ul>
///   <li>
///     <code>init(image:)</code> creates a session with the provided UIImage.
///   </li>
///   <li>
///     <code>init(asset:sessionReady:)</code> creates a session with the provided AVAsset.
///   </li>
///   <li>
///     <code>init(assets:sessionReady:)</code> creates a session with the provided AVAssets where each asset corresponds to a segment in the session video.
///   </li>
///   <li>
///     <code>init(assets:renderSize:sessionReady:)</code> creates a session of a specific pixel dimension and with the provided AVAssets where each asset corresponds to a segment in the session video.
///   </li>
/// </ul>
/// After a session is successfully created you may delete any local image/video files that you used to create the session.
/// <h3>Saving/Restoring Sessions</h3>
/// By default, all sessions are automatically saved to file and accessible from the users Drafts in the <code>LibraryController</code> and the <code>SessionManager.savedSessions</code> array. If you do not want a session to persist in memory and on disk, you should call <code>destroy()</code> when the session is no longer needed. No further action is required on your part.
/// If you want to know how to retrieve a saved session on startup see <code>SessionManager</code> for more information.
/// <h3>Modifying Sessions</h3>
/// Sessions can also be edited programmatically instead of visually.
/// For example, setting the primaryFilter of an image to <a href="https://www.pixelsdk.com/docs/latest/Classes/SessionFilterWilshire.html">Wilshire</a>:
/// \code
/// session.image!.primaryFilter = SessionFilterWilshire()
///
/// \endcodeApplying a <a href="https://www.pixelsdk.com/docs/latest/Classes/SessionFilterBrightness.html">Brightness</a> filter to an image:
/// \code
/// let brightnessFilter = SessionFilterBrightness()
/// brightnessFilter.normalizedIntensity = 0.2
/// session.image!.filters = [brightnessFilter]
///
/// \endcodeApplying a <a href="https://www.pixelsdk.com/docs/latest/Classes/SessionFilterSaturation.html">Saturation</a> filter to a whole video:
/// \code
/// let saturationFilter = SessionFilterSaturation()
/// saturationFilter.normalizedIntensity = 0.3
/// session.video!.filters = [saturationFilter]
///
/// \endcodeApplying a <a href="https://www.pixelsdk.com/docs/latest/Classes/SessionFilterContrast.html">Contrast</a> filter to the first segment of a video:
/// \code
/// let segment = session.video!.videoSegments.first!
/// let contrastFilter = SessionFilterContrast()
/// contrastFilter.normalizedIntensity = 0.2
/// segment.filters = [contrastFilter]
///
/// \endcodeTrimming a segment so it <a href="https://www.pixelsdk.com/docs/latest/Classes/SessionVideoSegment.html#/c:@M@PixelSDK@objc(cs)SessionVideoSegment(py)trimStartTime">starts</a> at one second in, with a <a href="https://www.pixelsdk.com/docs/latest/Classes/SessionVideoSegment.html#/c:@M@PixelSDK@objc(cs)SessionVideoSegment(py)trimDuration">duration</a> of two seconds:
/// \code
/// let segment = session.video!.videoSegments.first!
/// segment.trimStartTime = CMTime(seconds: 1, preferredTimescale: segment.duration.timescale)
/// segment.trimDuration = CMTime(seconds: 2, preferredTimescale: segment.duration.timescale)
///
/// \endcodeRotating the first segment of a video with <a href="https://www.pixelsdk.com/docs/latest/Classes/SessionVideoSegment.html#/c:@M@PixelSDK@objc(cs)SessionVideoSegment(py)preferredTransform">preferredTransform</a>:
/// \code
/// let segment = session.video!.videoSegments.first!
/// segment.preferredTransform = .rotated180Degrees(segment.naturalSize)
/// segment.cropRect = segment.suggestedCropRect()
///
/// \endcodeIncreasing the <a href="https://www.pixelsdk.com/docs/latest/Classes/SessionVideoSegment.html#/c:@M@PixelSDK@objc(cs)SessionVideoSegment(py)speedMultiplier">speed</a> of the first segment of a video:
/// \code
/// let segment = session.video!.videoSegments.first!
/// segment.speedMultiplier = 2 // 2x faster
///
/// \endcodeYou can present the <code>EditController</code> after making programmatic edits and it will reflect your changes. Additionally, the <code>PreviewController</code> will reflect all programmatic edits in real-time.
/// After making programmatic edits to a session, you should manually call <code>session.save()</code>.
/// warning:
/// If you make programmatic changes to a session that is currently displayed by an <code>EditController</code> it may result in undocumented behavior.
/// <h3>Exporting Session Media</h3>
/// See the <code>VideoExporter</code> and <code>ImageExporter</code> classes.
/// If you need to retrieve thumbnails for media, you can do so with the <code>SessionImage</code> and <code>SessionVideoSegment</code>  <code>requestThumbnail()</code> functions respectively.
SWIFT_CLASS("_TtC8PixelSDK7Session")
@interface Session : NSObject
/// Creates a <code>Session</code> with the provided image.
/// \param image The image to create the session with.
///
- (nonnull instancetype)initWithImage:(UIImage * _Nonnull)image;
/// An image associated with the session, if any.
/// A session will have either a video or image associated with it, but never both.
@property (nonatomic, readonly, strong) SessionImage * _Nullable image;
/// A video associated with the session, if any.
/// A session will have either a video or image associated with it, but never both.
@property (nonatomic, readonly, strong) SessionVideo * _Nullable video;
/// A unique ID assigned to this session.
@property (nonatomic, readonly) NSInteger sessionID;
/// UTC Date created, set when the session is first initialized.
@property (nonatomic, readonly, copy) NSDate * _Nonnull dateCreated;
/// UTC Date modified, set when the session is saved.
@property (nonatomic, readonly, copy) NSDate * _Nonnull dateModified;
/// Set this to any information you want associated with this session.
/// The SDK will handle calling <code>save()</code> after you set this.
/// Must be a valid JSON object. https://developer.apple.com/documentation/foundation/jsonserialization/1418461-isvalidjsonobject
/// Default value: <code>nil</code>
@property (nonatomic, copy) NSDictionary * _Nullable userInfo;
/// If the session can be found in the <code>SessionManager.savedSessions</code> array this will be true.
@property (nonatomic, readonly) BOOL isSaved;
/// If the session should never be saved, written to file or the <code>SessionManager.savedSessions</code> array, set this to true.
/// This is helpful if you need a temporary session that can be easily thrown away.
/// Anything that is written to file for this session (e.g. video files) will be deleted on next restart if you do not call <code>destroy()</code> before then. If you are creating many temporary sessions, make sure to call <code>destroy()</code> when done with a session to prevent memory or disk space from running out.
/// Default value: <code>false</code>
@property (nonatomic) BOOL isTransient;
/// Indicates if <code>destroy()</code> has been called on the session.
/// Default value: <code>false</code>
@property (nonatomic, readonly) BOOL destroyed;
/// Set this to true if you do not want this session to appear in Drafts on the <code>LibraryController</code>.
/// warning:
/// Improper usage of this may lead to runaway growth of <code>SessionManager.savedSessions</code> array
/// and disk usage since all sessions are automatically saved. You may be unaware that the session still
/// exists since it will not be visible in your Drafts.
/// Default value: <code>false</code>
@property (nonatomic) BOOL hidden;
/// The SDK automatically saves every <code>Session</code> that interacts with a view controller (<code>EditController</code>, <code>LibraryController</code>, <code>CameraController</code>) so you should not need to call this.
/// You should only call this when you have finished making a set of programmatic changes to a session.
/// When a session is saved it will be written to file and inserted into the <code>SessionManager.savedSessions</code> array (if not already present). It will also appear in the users Drafts on the <code>LibraryController</code>.
/// Every variable in the session will be saved, unless the documentation for a specific variable explicitly states:
/// “Does not persist.”
/// precondition:
/// <code>isTransient</code> and <code>destroyed</code> must be false for a session to successfully save.
- (void)save;
/// Sessions are automatically saved so you a responsible for calling this when you are done with a session (unless noted otherwise). If you do not destroy a session it will persist in the users Drafts in memory and on disk.
/// A documentation example of where a session should not be destroyed is in the <code>ContainerControllerDelegate.containerController(_:willShowEditController:withSession:)</code> delegate call.
/// This deletes all files associated with a session (videos, images, etc.), removes it from the <code>SessionManager.savedSessions</code> array and sets the <code>destroyed</code> variable to true.
/// After calling this, the session can no longer be used and you should begin releasing all references to it.
- (void)destroy;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CLLocation;
@class NSURL;

/// For more information see <code>Session</code> documentation.
SWIFT_CLASS("_TtC8PixelSDK12SessionImage")
@interface SessionImage : NSObject
/// The pixel dimensions of the original image. Does not take into account the preferredTransform.
@property (nonatomic, readonly) CGSize naturalSize;
/// The pixel dimensions of the original image with the preferredTransform taken into account.
@property (nonatomic, readonly) CGSize actualSize;
/// The pixel dimensions of the final image.
/// If there is a cropRect, this will be equal to the size of the cropRect. Otherwise it is equal to the actualSize.
@property (nonatomic, readonly) CGSize renderSize;
/// The preferredTransform takes into account any rotation that should be made to the image.
/// If the image originally came with an orientation, it will be converted into the preferredTransform.
/// Any rotation made by the <code>EditController</code> will also be reflected here.
/// Default value: <code>.identity</code>
@property (nonatomic) CGAffineTransform preferredTransform;
/// If the image came from the users Photo Library and there was location information associated, this will be set.
/// See the <a href="https://developer.apple.com/documentation/corelocation/cllocation">documentation</a> for CLLocation.
/// Default value: <code>nil</code>
@property (nonatomic, strong) CLLocation * _Nullable location;
/// The URL location of the final JPEG image file after it has been exported. There will only be a file here after an export has been completed. You may move, copy or delete this file. See <code>ImageExporter</code> for more information.
@property (nonatomic, readonly, copy) NSURL * _Nonnull exportedImageURL;
/// The UTC date when the last successful image export started.
@property (nonatomic, readonly, copy) NSDate * _Nullable dateExported;
/// Indicates if the export was completed.
/// If the sessions dateModified is an older date than the images dateExported, this will be false. In other words, if you export the image this will become true but if you then make modifications to the image this will flip back to false. The exportedImageURL file must also exist for this to be true.
@property (nonatomic, readonly) BOOL isExported;
/// Clears the thumbnail cache.
- (void)invalidateThumbnails;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// By default, all sessions are automatically saved to file and accessible from the users Drafts in the <code>LibraryController</code> and the <code>savedSessions</code> array.
/// The <code>SessionManager</code> is responsible for automatically restoring saved sessions when the application starts. The <code>savedSessions</code> array will be populated and the <code>DidRestoreSavedSessionsNotification</code> will be called when the session manager has finished restoring the sessions. If you are accessing the <code>savedSessions</code> array and displaying its contents you should refresh your UI when the notification is posted.
/// You must call <code>PixelSDK.setup()</code> from your App Delegate to guarantee the <code>savedSessions</code> array is populated when the application starts, otherwise we will attempt to populate it at a later point.
/// <h3>Retrieving a Session</h3>
/// If you want to retrieve a specific session after your application restarts, simply save its <code>sessionID</code> beforehand. You can save it in user defaults or your own data structure. For example with user defaults:
/// \code
/// let savedSessionID = session.sessionID
/// UserDefaults.standard.set(savedSessionID, forKey: "mySessionID")
///
/// \endcodeAnd then at a later point (after a restart, etc.) you can retrieve the session using the ID you saved:
/// \code
/// if let savedSessionID = UserDefaults.standard.object(forKey: "mySessionID") as? Int,
///     let session = SessionManager.shared.savedSessions.first { $0.sessionID == savedSessionID } {
///     // Retrieved session!
/// }
///
/// \endcodeAll sessions are automatically saved, so you only need to worry about saving the <code>sessionID</code> and retrieving the session from the <code>savedSessions</code> array. If you destroy the session or delete the session from your drafts, you will no longer be able to retrieve the session.
/// Another option for retrieving a session is to simply set some identifying <code>userInfo</code> on the session beforehand.
/// For example:
/// \code
/// session.userInfo = ["my_internal_id": 2]
///
/// \endcodeAnd then at a later point (after a restart, etc.) you can retrieve the session by finding the session with your user info:
/// \code
/// for session in SessionManager.shared.savedSessions {
///     if let myInternalID = session.userInfo?["my_internal_id"] as? Int,
///         myInternalID == 2 {
///         // Retrieved session!
///     }
/// }
///
/// \endcode
SWIFT_CLASS("_TtC8PixelSDK14SessionManager")
@interface SessionManager : NSObject
/// Use this to access the shared instance of the <code>SessionManager</code>.
/// For example to access the saved sessions:
/// \code
/// print("Saved Sessions: \(SessionManager.shared.savedSessions)")
///
/// \endcode
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) SessionManager * _Nonnull shared;)
+ (SessionManager * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// This array contains all sessions that have been saved. The contents of this array will be displayed as the Drafts section of the <code>LibraryController</code>. If a session is deleted from Drafts or <a href="https://www.pixelsdk.com/docs/latest/Classes/Session.html#/c:@M@PixelSDK@objc(cs)Session(im)destroy">destroyed</a> it will be removed from this array.
/// For example to access the saved sessions:
/// \code
/// print("Saved Sessions: \(SessionManager.shared.savedSessions)")
///
/// \endcode
@property (nonatomic, readonly, copy) NSArray<Session *> * _Nonnull savedSessions;
/// This will be true after the <code>savedSessions</code> array has been populated. This will be set to true shortly after the application starts.
/// Default value: <code>false</code>
@property (nonatomic, readonly) BOOL didRestoreSavedSessions;
/// This notification will be posted to the default NotificationCenter from the main thread after the <code>savedSessions</code> array has been populated. This will happen shortly after the application starts.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull DidRestoreSavedSessionsNotification;)
+ (NSNotificationName _Nonnull)DidRestoreSavedSessionsNotification SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// For more information see <code>Session</code> documentation.
SWIFT_CLASS("_TtC8PixelSDK12SessionVideo")
@interface SessionVideo : NSObject
/// The pixel dimensions of the final video.
/// If not manually set, this will be equal to the size of the cropRect of the first segment. If there is no cropRect, it is equal to the actualSize of the first segment. If the first segment later changes, the renderSize will not also change.
/// If you manually change the renderSize, you will need to update the cropRect for each segment if the renderSize width/height ratio has changed. You can avoid this by setting the <code>CameraController</code> <code>CameraController.aspectRatio</code> and <code>PreviewCropController</code> <code>PreviewCropController.aspectRatio</code> beforehand.
/// If you provide floating point numbers, they will be rounded using the Drawin.round() function.
/// If you provide odd numbers, they will be reduced to the next lower even number, e.g. 5 becomes 4. This is because AVFoundation can’t handle odd pixel dimensions when writing video files and will instead substitute in a green line.
@property (nonatomic) CGSize renderSize;
/// The video segments in the video.
/// precondition:
/// There must be one or more videoSegments.
@property (nonatomic, readonly, copy) NSArray<SessionVideoSegment *> * _Nonnull videoSegments;
/// The total duration of the video.
/// Calculated by adding the <code>SessionVideoSegment.renderDuration</code> of every segment together.
@property (nonatomic, readonly) CMTime duration;
/// The framerate for the video.
/// For example, a frameDuration of 1/30th of a second <code>CMTime(value: 1, timescale: 30)</code> would be a 30fps video.
/// If not manually set, it is calculated by picking the shortest frameDuration from the segments. In other words, it picks the highest framerate from the segments. This is similar to the method used by <a href="https://developer.apple.com/documentation/avfoundation/avvideocomposition/1385892-videocompositionwithpropertiesof?language=objc">videoCompositionWithPropertiesOfAsset:</a>.
/// Will be <code>CMTime.positiveInfinity</code> if the video has no segments.
@property (nonatomic) CMTime frameDuration;
/// The playback speed of the video.
/// precondition:
/// Must be greater than zero.
/// note:
/// The speed of individual segments can be set with <code>SessionVideoSegment</code> <code>SessionVideoSegment.speedMultiplier</code> instead.
/// For example:
/// A value of <code>2</code> with result in 2x faster playback speed.
/// A value of <code>.5</code> will result .5x slower playback speed.
/// A value of <code>1</code> will result in normal playback speed.
/// Default value: <code>1</code>
@property (nonatomic) double speedMultiplier;
/// The URL location of the final video file (with all segments stiched together) after it has been exported. There will only be a file here after the export has been completed for the video. You may move, copy or delete this file. See <code>VideoExporter</code> for more information.
@property (nonatomic, readonly, copy) NSURL * _Nonnull exportedVideoURL;
/// The UTC date when the last successful video export started.
@property (nonatomic, readonly, copy) NSDate * _Nullable dateExported;
/// Indicates if the export was completed.
/// If the sessions dateModified is an older date than the videos dateExported, this will be false. In other words, if you export the video this will become true but if you then make modifications to the video this will flip back to false. The exportedVideoURL file must also exist for this to be true.
@property (nonatomic, readonly) BOOL isExported;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// For more information see <code>Session</code> documentation.
SWIFT_CLASS("_TtC8PixelSDK19SessionVideoSegment")
@interface SessionVideoSegment : NSObject
/// The pixel dimensions of the original video. Does not take into account the preferredTransform.
@property (nonatomic, readonly) CGSize naturalSize;
/// The pixel dimensions of the original video with the preferredTransform taken into account.
@property (nonatomic, readonly) CGSize actualSize;
/// The preferredTransform takes into account any rotation that should be made to the video segment.
/// If the video segment originally came with a preferredTransform, it will be set here.
/// 90° rotation increments made by the <code>EditController</code> will also be reflected here.
/// Default value: <code>.identity</code>
@property (nonatomic) CGAffineTransform preferredTransform;
/// This returns a suggested cropRect for the segment. The returned cropRect will always touch two opposite edges of the segment actualSize and will be centered inside. The cropRect width/height ratio will match the video renderSize width/height ratio.
- (CGRect)suggestedCropRect SWIFT_WARN_UNUSED_RESULT;
/// The start time of the video segment after it has been trimmed.
/// <code>.zero</code> corresponds with a start time at the beginning of the video segment.
/// Speed is not factored into this time.
/// precondition:
/// Cannot be greater than <code>duration</code> and cannot be negative.
/// Default value: <code>.zero</code>
@property (nonatomic) CMTime trimStartTime;
/// The duration of the video segment after it has been trimmed.
/// This is the duration of video to play after the <code>trimStartTime</code>.
/// Speed is not factored into this time.
/// precondition:
/// Cannot be greater than <code>duration</code> - <code>trimStartTime</code> and cannot be negative.
/// Default value: <code>duration</code>
@property (nonatomic) CMTime trimDuration;
/// The final duration of the video segment after it has been trimmed and speed multipliers divided in.
/// Default value: <code>SessionVideoSegment.trimDuration</code> \ <code>SessionVideoSegment.speedMultiplier</code> \ <code>SessionVideo</code> <code>SessionVideo.speedMultiplier</code>
@property (nonatomic, readonly) CMTime renderDuration;
/// The original duration of the video segment. Originates from the <a href="https://developer.apple.com/documentation/avfoundation/avassettrack/1388335-timerange">timeRange</a> of the original AVAsset.
@property (nonatomic, readonly) CMTime duration;
/// The framerate for the video segment. Originates from the <a href="https://developer.apple.com/documentation/avfoundation/avassettrack/1388608-minframeduration">minFrameDuration</a> of the original AVAsset.
/// For example, a frameDuration of 1/30th of a second <code>CMTime(value: 1, timescale: 30)</code> would be a 30fps video segment.
/// Will be <code>CMTime(value: 1, timescale: 30)</code> if the minFrameDuration of the AVAsset is not known or cannot be calculated.
@property (nonatomic) CMTime frameDuration;
/// The playback speed for the current segment.
/// precondition:
/// Must be greater than zero.
/// note:
/// The speed of the whole video can be set with <code>SessionVideo</code> <code>SessionVideo.speedMultiplier</code> instead.
/// For example:
/// A value of <code>2</code> with result in 2x faster playback speed.
/// A value of <code>.5</code> will result .5x slower playback speed.
/// A value of <code>1</code> will result in normal playback speed.
/// Default value: <code>1</code>
@property (nonatomic) double speedMultiplier;
/// If the video segment came from the users Photo Library and there was location information associated, this will be set.
/// See the <a href="https://developer.apple.com/documentation/corelocation/cllocation">documentation</a> for CLLocation.
/// Default value: <code>nil</code>
@property (nonatomic, strong) CLLocation * _Nullable location;
/// The URL location of the final video segment file after it has been exported. There will only be a file here after an export has been completed for the individual segment. You may move, copy or delete this file. See <code>VideoExporter</code> for more information.
@property (nonatomic, readonly, copy) NSURL * _Nonnull exportedVideoURL;
/// The UTC date when the last successful video segment export started.
@property (nonatomic, readonly, copy) NSDate * _Nullable dateExported;
/// Indicates if the export was completed for the individual segment.
/// If the sessions dateModified is an older date than the video segments dateExported, this will be false. In other words, if you export the video segment this will become true but if you then make modifications to the video segment this will flip back to false. The exportedVideoURL file must also exist for this to be true.
@property (nonatomic, readonly) BOOL isExported;
/// Clears the thumbnail cache.
- (void)invalidateThumbnails;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end














#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#endif
